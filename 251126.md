# AI 활용보고서

- 사용 AI: ChatGPT 5
- 문제: 캠퍼스 플래너 콘솔 프로그램

---

### 최소영
### 프롬프트
FrienRepository 인터페이스에는 어떤 기능까지 포함시키고 어떤 로직은 Service 쪽으로 유지하는 것이 바람직한지 설계 기준을 알려줄래?

---

### 결과

좋아!

“FriendRepository 인터페이스에는 어떤 기능까지 넣고, 어떤 로직은 Service에 남겨야 하는가?”

이 질문은 객체지향 설계에서 아주 중요하고, Repository 패턴·DIP·SRP와 모두 연결돼.

아래에서 설계 기준 → 포함해야 하는 기능 → 포함하면 안 되는 기능 → 왜 그런지까지 아주 명확하게 정리해줄게.

## FriendRepository 인터페이스에는 어떤 기능까지 포함시키고, 어떤 로직은 Service 계층에 남겨야 하는지

Friend 기능을 좋은 코드로 만들기 위해서는

- Repository → “데이터 접근 책임”,

- Service → “비즈니스 규칙 책임”

으로 분리하는 것이 필수적이다.

아래는 왜, 어떻게, 무엇을 기준으로 분리해야 하는지 매우 자세하게 설명한 내용이다.

## 1. 설계 철학 ― Repository와 Service는 “완전히 다른 역할”이다

소프트웨어 설계에서 가장 중요한 3가지 원칙은 다음과 같다.

### SRP (단일 책임 원칙)

- Repository: 저장/조회에 대한 책임만 가져야 함

- Service: 검증/비즈니스 규칙/정책 결정을 담당해야 함
→ 이 둘이 섞이면 유지보수 지옥이 된다.


### DIP (의존성 역전 원칙)

- Service는 인터페이스(FriendRepository) 에만 의존해야 한다.

- Repository 구현체(LocalStoreFriendRepository, MySqlFriendRepository)는 인터페이스 뒤에 숨어야 한다.


### OCP (확장엔 열려 있고 변경엔 닫혀있어야 한다)


- 저장 방식이 LocalStore든 DB든 Service는 수정되면 안 된다.
  
→ 이를 위해 Repository 인터페이스가 필요하다.



## 2. FriendRepository에서 해야 하는 일 (포함해야 하는 기능)

Repository는 **“저장소(DataSource)에 아무리 변화가 있어도 공통적으로 수행할 수 있는 동작”**만 포함해야 한다.

즉, CRUD + 검색.

### (1) create() – 저장 및 ID 할당

Repository 코드 예시

```java
@Override
public Friend create(String name, String uid, String tag) {
    long id = store.friendSeq++;
    Friend f = new Friend(id, name, uid, tag);
    store.friends.add(f);
    db.save(store);
    return f;
}
```

여기서 Repository는 “어떻게 저장하는가(LocalStore + 파일 IO)”만 알고 있고,

‘왜 저장하는가’는 전혀 모르도록 만들어야 한다.

### (2) save() – 수정된 Friend 저장

```java
@Override
public Friend save(Friend friend) {
    for (int i = 0; i < store.friends.size(); i++) {
        if (store.friends.get(i).getId() == friend.getId()) {
            store.friends.set(i, friend);
            db.save(store);
            return friend;
        }
    }
    store.friends.add(friend);
    db.save(store);
    return friend;
}
```

Repository는 “어디에 저장할까?”만 고민한다.

Service는 “정말 저장해도 되는가?”를 판단한다.

### (3) findById()

```java
@Override
public Optional<Friend> findById(long id) {
    return store.friends.stream()
            .filter(f -> f.getId() == id)
            .findFirst();
}
```

### (4) findByUid()

UID 중복 검증은 Service가 하지만

“UID로 조회해서 해당 UID가 존재하는지 확인하는 것”은 Repository 책임이다.

```java
@Override
public Optional<Friend> findByUid(String uid) {
    return store.friends.stream()
            .filter(f -> f.getUid().equalsIgnoreCase(uid))
            .findFirst();
}
```

### (5) findAll(), findByTag() 등 일반 조회 기능

```java
@Override
public List<Friend> findByTag(String tag) {
    return store.friends.stream()
            .filter(f -> tag.equalsIgnoreCase(f.getTag()))
            .toList();
}
```

조회는 Repository의 순수한 책임이다.

### (6) deleteById()

```java
@Override
public void deleteById(long id) {
    store.friends.removeIf(f -> f.getId() == id);
    db.save(store);
}
```

## 정리: Repository는 “저장소가 제공 가능한 기능”만 넣는다는 것이 가장 핵심이다.
비즈니스 로직을 넣기 시작하면 망한다.


## 3. FriendService에서 해야 할 일 (넣지 말아야 할 기능)

아래 기능들은 절대 Repository에 넣으면 안 된다.

왜냐면 Repository는 저장 기술에 대한 계층이고,

비즈니스 규칙을 다루기 시작하면 “도메인 → 저장소”가 뒤섞여 버리기 때문이다.

### FriendRepository에 넣으면 안 되는 기능들
(= Service가 책임져야 하는 기능)

#### (1) UID 형식 검증

예: uid_123 형태인지 검사

```java
private void validateUidFormat(String uid) {
    if (!uidPattern.matcher(uid).matches()) {
        throw new IllegalArgumentException("UID 형식 오류");
    }
}
```

Repository는 데이터 저장만 해야지,

“이 UID가 규칙에 맞는지”는 도메인 규칙이라서 Service가 해야 한다.

#### (2) UID 중복 검증

중복 조회(findByUid)는 Repository 책임이지만,

“중복이면 예외 던질지”는 Service의 정책이다.

```java
private void validateUidUnique(String uid, Long ignoreId) {
    Optional<Friend> f = repository.findByUid(uid);
    if (f.isPresent() && !f.get().getId().equals(ignoreId)) {
        throw new IllegalArgumentException("이미 존재하는 UID입니다.");
    }
}
```

Repository가 이걸 해버리면

저장소가 정책을 결정해버리는 말도 안 되는 구조가 된다.

#### (3) 이름 빈칸 검증

```java
private void validateName(String name) {
    if (name == null || name.isBlank()) {
        throw new IllegalArgumentException("이름은 비워 둘 수 없습니다.");
    }
}
```

#### (4) 수정 시 어떤 필드가 변경 가능한지 결정하는 로직

예:

- 빈칸이면 변경 X


- 변경된 값만 저장


- UID 변경 시 중복 검증


이것은 100% 서비스의 책임이다.

#### (5) 예외 메시지 + 정책 결정

예:


- “해당 ID의 친구가 없습니다.”


- “이미 존재하는 UID입니다.”


- “UID 형식 오류”


왜냐하면 Repository는 저장 방식에 대한 계층일 뿐

도메인 규칙을 알면 안 된다.

#### (6) Friend 도메인 변경 로직을 Repository에서 하면 안 됨

Friend changeName/changeUid/changeTag 같은 메서드를 Repository가 호출하면 안 된다.

Repository는 오직 “save() 해야 할 Friend가 오면 저장할 뿐”이다.


## 4. FriendService가 Repository 위에서 어떤 역할을 해야 하는지 (예시로 설명)

### 친구 추가

```java
public Friend addFriend(String name, String uid, String tag) {
    validateName(name);
    validateUidFormat(uid);
    validateUidUnique(uid, null);

    return repository.create(name.trim(), uid.trim(), tag);
}
```

Repository가 할 일은 create() 뿐이다.

Service는 정책을 모두 담당한다.

### 이름/UID 수정

```java
public void updateFriend(long id, String newName, String newUid) {
    Friend f = repository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("해당 ID의 친구가 없습니다."));

    if (newName != null && !newName.isBlank()) {
        validateName(newName);
        f.changeName(newName);
    }

    if (newUid != null && !newUid.isBlank()) {
        validateUidFormat(newUid);
        validateUidUnique(newUid, f.getId());
        f.changeUid(newUid);
    }

    repository.save(f);
}
```

### 태그 수정

```java
public void updateTag(long id, String tag) {
    Friend f = repository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("해당 ID의 친구가 없습니다."));

    f.changeTag(tag);
    repository.save(f);
}
```

## 5. 설계 기준을 한 문단으로 요약하면 이렇게 된다

Repository 인터페이스에는 저장소 기술과 무관하게 공통적으로 수행할 수 있는 데이터 접근 동작(CRUD, 조회 기능)만 포함하고,

비즈니스 규칙(검증, 중복 검사, 정책 결정, 예외 처리, 필드 변경 로직)은 모두 Service 계층에 둔다.

이렇게 해야 SRP를 적용할 수 있고, DIP를 실현하며, 저장소 변경(LocalStore → DB) 시 Service를 수정하지 않아도 된다.


## 원하면 더 만들어줄 수 있어

UML 구조 다이어그램


Before → After 설계 비교

FriendRepository와 FriendService의 책임 분리 표


말만 하면 바로 만들어줄게!
