# AI 활용보고서

- 사용 AI: ChatGPT 5
- 문제: 캠퍼스 플래너 콘솔 프로그램

---

### 최소영
### 프롬프트
FrienRepository 인터페이스에는 어떤 기능까지 포함시키고 어떤 로직은 Service 쪽으로 유지하는 것이 바람직한지 설계 기준을 알려줄래?

---

### 결과

좋아!

“FriendRepository 인터페이스에는 어떤 기능까지 넣고, 어떤 로직은 Service에 남겨야 하는가?”

이 질문은 객체지향 설계에서 아주 중요하고, Repository 패턴·DIP·SRP와 모두 연결돼.

아래에서 설계 기준 → 포함해야 하는 기능 → 포함하면 안 되는 기능 → 왜 그런지까지 아주 명확하게 정리해줄게.

## FriendRepository 인터페이스에는 어떤 기능까지 포함시키고, 어떤 로직은 Service 계층에 남겨야 하는지

Friend 기능을 좋은 코드로 만들기 위해서는

- Repository → “데이터 접근 책임”,

- Service → “비즈니스 규칙 책임”

으로 분리하는 것이 필수적이다.

아래는 왜, 어떻게, 무엇을 기준으로 분리해야 하는지 매우 자세하게 설명한 내용이다.

## 1. 설계 철학 ― Repository와 Service는 “완전히 다른 역할”이다

소프트웨어 설계에서 가장 중요한 3가지 원칙은 다음과 같다.

### SRP (단일 책임 원칙)

- Repository: 저장/조회에 대한 책임만 가져야 함

- Service: 검증/비즈니스 규칙/정책 결정을 담당해야 함
→ 이 둘이 섞이면 유지보수 지옥이 된다.


### DIP (의존성 역전 원칙)

- Service는 인터페이스(FriendRepository) 에만 의존해야 한다.

- Repository 구현체(LocalStoreFriendRepository, MySqlFriendRepository)는 인터페이스 뒤에 숨어야 한다.


### OCP (확장엔 열려 있고 변경엔 닫혀있어야 한다)


- 저장 방식이 LocalStore든 DB든 Service는 수정되면 안 된다.
  
→ 이를 위해 Repository 인터페이스가 필요하다.



## 2. FriendRepository에서 해야 하는 일 (포함해야 하는 기능)

Repository는 **“저장소(DataSource)에 아무리 변화가 있어도 공통적으로 수행할 수 있는 동작”**만 포함해야 한다.

즉, CRUD + 검색.

### (1) create() – 저장 및 ID 할당

Repository 코드 예시

```java
@Override
public Friend create(String name, String uid, String tag) {
    long id = store.friendSeq++;
    Friend f = new Friend(id, name, uid, tag);
    store.friends.add(f);
    db.save(store);
    return f;
}
```

여기서 Repository는 “어떻게 저장하는가(LocalStore + 파일 IO)”만 알고 있고,

‘왜 저장하는가’는 전혀 모르도록 만들어야 한다.

### (2) save() – 수정된 Friend 저장

```java
@Override
public Friend save(Friend friend) {
    for (int i = 0; i < store.friends.size(); i++) {
        if (store.friends.get(i).getId() == friend.getId()) {
            store.friends.set(i, friend);
            db.save(store);
            return friend;
        }
    }
    store.friends.add(friend);
    db.save(store);
    return friend;
}
```

Repository는 “어디에 저장할까?”만 고민한다.

Service는 “정말 저장해도 되는가?”를 판단한다.

### (3) findById()

```java
@Override
public Optional<Friend> findById(long id) {
    return store.friends.stream()
            .filter(f -> f.getId() == id)
            .findFirst();
}
```

### (4) findByUid()

UID 중복 검증은 Service가 하지만

“UID로 조회해서 해당 UID가 존재하는지 확인하는 것”은 Repository 책임이다.

```java
@Override
public Optional<Friend> findByUid(String uid) {
    return store.friends.stream()
            .filter(f -> f.getUid().equalsIgnoreCase(uid))
            .findFirst();
}
```

### (5) findAll(), findByTag() 등 일반 조회 기능

```java
@Override
public List<Friend> findByTag(String tag) {
    return store.friends.stream()
            .filter(f -> tag.equalsIgnoreCase(f.getTag()))
            .toList();
}
```

조회는 Repository의 순수한 책임이다.

### (6) deleteById()

```java
@Override
public void deleteById(long id) {
    store.friends.removeIf(f -> f.getId() == id);
    db.save(store);
}
```

## 정리: Repository는 “저장소가 제공 가능한 기능”만 넣는다는 것이 가장 핵심이다.
비즈니스 로직을 넣기 시작하면 망한다.


## 3. FriendService에서 해야 할 일 (넣지 말아야 할 기능)

아래 기능들은 절대 Repository에 넣으면 안 된다.

왜냐면 Repository는 저장 기술에 대한 계층이고,

비즈니스 규칙을 다루기 시작하면 “도메인 → 저장소”가 뒤섞여 버리기 때문이다.

### FriendRepository에 넣으면 안 되는 기능들
(= Service가 책임져야 하는 기능)

#### (1) UID 형식 검증

예: uid_123 형태인지 검사

```java
private void validateUidFormat(String uid) {
    if (!uidPattern.matcher(uid).matches()) {
        throw new IllegalArgumentException("UID 형식 오류");
    }
}
```

Repository는 데이터 저장만 해야지,

“이 UID가 규칙에 맞는지”는 도메인 규칙이라서 Service가 해야 한다.

#### (2) UID 중복 검증

중복 조회(findByUid)는 Repository 책임이지만,

“중복이면 예외 던질지”는 Service의 정책이다.

```java
private void validateUidUnique(String uid, Long ignoreId) {
    Optional<Friend> f = repository.findByUid(uid);
    if (f.isPresent() && !f.get().getId().equals(ignoreId)) {
        throw new IllegalArgumentException("이미 존재하는 UID입니다.");
    }
}
```

Repository가 이걸 해버리면

저장소가 정책을 결정해버리는 말도 안 되는 구조가 된다.

#### (3) 이름 빈칸 검증

```java
private void validateName(String name) {
    if (name == null || name.isBlank()) {
        throw new IllegalArgumentException("이름은 비워 둘 수 없습니다.");
    }
}
```

#### (4) 수정 시 어떤 필드가 변경 가능한지 결정하는 로직

예:

- 빈칸이면 변경 X


- 변경된 값만 저장


- UID 변경 시 중복 검증


이것은 100% 서비스의 책임이다.

#### (5) 예외 메시지 + 정책 결정

예:


- “해당 ID의 친구가 없습니다.”


- “이미 존재하는 UID입니다.”


- “UID 형식 오류”


왜냐하면 Repository는 저장 방식에 대한 계층일 뿐

도메인 규칙을 알면 안 된다.

#### (6) Friend 도메인 변경 로직을 Repository에서 하면 안 됨

Friend changeName/changeUid/changeTag 같은 메서드를 Repository가 호출하면 안 된다.

Repository는 오직 “save() 해야 할 Friend가 오면 저장할 뿐”이다.


## 4. FriendService가 Repository 위에서 어떤 역할을 해야 하는지 (예시로 설명)

### 친구 추가

```java
public Friend addFriend(String name, String uid, String tag) {
    validateName(name);
    validateUidFormat(uid);
    validateUidUnique(uid, null);

    return repository.create(name.trim(), uid.trim(), tag);
}
```

Repository가 할 일은 create() 뿐이다.

Service는 정책을 모두 담당한다.

### 이름/UID 수정

```java
public void updateFriend(long id, String newName, String newUid) {
    Friend f = repository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("해당 ID의 친구가 없습니다."));

    if (newName != null && !newName.isBlank()) {
        validateName(newName);
        f.changeName(newName);
    }

    if (newUid != null && !newUid.isBlank()) {
        validateUidFormat(newUid);
        validateUidUnique(newUid, f.getId());
        f.changeUid(newUid);
    }

    repository.save(f);
}
```

### 태그 수정

```java
public void updateTag(long id, String tag) {
    Friend f = repository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("해당 ID의 친구가 없습니다."));

    f.changeTag(tag);
    repository.save(f);
}
```

## 5. 설계 기준을 한 문단으로 요약하면 이렇게 된다

Repository 인터페이스에는 저장소 기술과 무관하게 공통적으로 수행할 수 있는 데이터 접근 동작(CRUD, 조회 기능)만 포함하고,

비즈니스 규칙(검증, 중복 검사, 정책 결정, 예외 처리, 필드 변경 로직)은 모두 Service 계층에 둔다.

이렇게 해야 SRP를 적용할 수 있고, DIP를 실현하며, 저장소 변경(LocalStore → DB) 시 Service를 수정하지 않아도 된다.


## 원하면 더 만들어줄 수 있어

UML 구조 다이어그램


Before → After 설계 비교

FriendRepository와 FriendService의 책임 분리 표


말만 하면 바로 만들어줄게!



---

### 프롬프트
UID 입력 시 공백 trim, null 검사, 재입력 플로우 등을 FriendUI가 감당하게 할지 아니면 FriendService에 맡기고 UI는 단순히 필요한 입력만 받아야 하는지 최적의 책임 분배 방식을 알려줘

--- 

### 결과


## 1. “입력 처리 vs. 유효성 검증” 문제는 모든 소프트웨어 아키텍처의 핵심 질문이다

사용자 입력이라는 건 본질적으로 더러운(dirty) 데이터다.

공백, 오타, 비어있는 값, 잘못된 날짜 형식, 중복된 값 등

오류를 만들 수 있는 모든 요소는 입력으로부터 발생한다.

### 소프트웨어가 커질수록 입력 경로는 다양해진다:

- 콘솔 입력

- GUI 텍스트 필드

- REST API 요청 바디

- Android 앱 폼 입력

- 웹에서 JSON 요청

- 스케줄러 자동 입력

어느 경로에서 들어오든 Service는 동일한 규칙을 적용할 수 있어야 한다.

### 그래서 현대 소프트웨어 설계의 원칙:

“UI는 데이터의 전달자일 뿐이고, 규칙은 Service 또는 Domain이 결정한다.”

이를 깨뜨리면 어떤 UI로 오든 검증을 다시 만들어야 한다.
결과적으로 대규모 중복 코드가 생기고 오류가 자주 생긴다.

## 2. FriendUI가 담당해야 하는 책임과 이유

UI는 사람과의 상호작용 담당자다.

입력받고 출력하고 오류 메시지를 보여주는 것이 전부이고

데이터의 의미를 판단해서는 안 된다.

### 2-1. “입력 흐름(FLOW)”은 UI의 책임

예:

```
오류: UID 형식 오류
다시 입력하시겠습니까? (y/n):
```

이런 흐름 제어는 UI가 해야 한다.

이건 비즈니스 규칙이 아니라 “사용자 차원”의 규칙이기 때문.

Service는 “사람과 대화하는 객체”가 아니므로

“다시 입력?” 같은 UX 요소를 알면 안 된다.

## 3. FriendService가 담당해야 하는 책임과 이유

### Service의 핵심 원칙:

Service는 항상 올바른 데이터를 Repository로 보낸다.

그러기 위해 데이터 정제(trim), 유효성 검증, 도메인 규칙 확인을 한다.

### UI에서 검증을 하게 되면:

- UI마다 다른 검증 코드가 중복됨

- Repository는 “이게 정상인지” 보장할 수 없음

- 콘솔, 웹, 모바일 UI 모두 검증을 또 써야 함

- 테스트가 어려워짐

### Service에서 검증을 담당하면:

- UI 종류가 바뀌어도 Service는 그대로 사용 가능

- Repository는 안전한 값만 받음

- 테스트가 매우 쉬워짐 (Service 단독 테스트 가능)

- 코드가 레이어별 책임을 유지하여 SRP 준수

## 4. Service에서 해야 하는 실제 코드 예시

```java
FriendService 내부 — 모든 검증, trim, 중복 검사
public Friend addFriend(String name, String uid, String tag) {

    validateName(name);       // blank, null
    validateUidFormat(uid);   // uid_숫자
    validateUidUnique(uid, null); // DB 중복 검사

    return repository.create(
        name.trim(),
        uid.trim(),
        (tag == null || tag.isBlank() ? null : tag.trim())
    );
}
```

검증 메서드
```java
private void validateName(String name) {
    if (name == null || name.isBlank())
        throw new IllegalArgumentException("이름은 비워둘 수 없습니다.");
}

private void validateUidFormat(String uid) {
    if (uid == null || uid.isBlank())
        throw new IllegalArgumentException("UID는 필수입니다.");

    if (!uid.matches("^uid_\\d+$"))
        throw new IllegalArgumentException("UID 형식 오류: uid_숫자 형태여야 합니다.");
}

private void validateUidUnique(String uid, Long ignoreId) {
    repository.findByUid(uid.trim())
            .ifPresent(friend -> {
                if (ignoreId == null || friend.getId() != ignoreId)
                    throw new IllegalArgumentException("이미 존재하는 UID입니다.");
            });
}
```

여기에서 trim()을 UI가 하지 않고 Service가 담당하는 이유는

다른 UI(웹/모바일)에서도 동일한 규칙이 적용되도록 하기 위함이다.

## 5. UI가 담당해야 하는 상세 코드 예시 (입력 흐름)

FriendUI 내부
```java
private void handleAdd(Scanner sc) {

    System.out.print("이름: ");
    String name = sc.nextLine();

    String uid, tag;

    while (true) {
        try {
            System.out.print("UID (uid_숫자): ");
            uid = sc.nextLine();

            System.out.print("태그(Enter 가능): ");
            tag = sc.nextLine();

            Friend created = service.addFriend(name, uid, tag);
            System.out.println("추가됨: " + created);
            break;

        } catch (Exception e) {
            System.out.println("오류: " + e.getMessage());
            System.out.print("다시 입력하시겠습니까? (y/n): ");
            String retry = sc.nextLine().trim().toLowerCase();
            if (!retry.equals("y")) {
                System.out.println("친구 추가 취소됨");
                return;
            }
        }
    }
}
```

UI는 사람들이 입력하고, 잘못 입력하면 UI의 흐름에서 다시 입력을 요구하는 역할만 한다.

도메인 규칙에 대한 판단은 Service가 하고,

UI는 그 결과(예외 메시지)를 단순히 화면에 보여줄 뿐이다.

##  6. UI가 검증까지 하게 되면 어떤 재앙이 생기는가 (현실 사례)

### 예: UI에서 trim 하고, blank 검사도 하고, UID 형식 검사도 한다고 치자

```java
String uid = sc.nextLine().trim();

if (!uid.startsWith("uid_")) {
    System.out.println("형식 오류");
    return;
}
```

이제 문제 시작:

1. 나중에 Android UI도 추가하려고 할 때
   
→ Android에서도 truncation, 형식 검사, 중복 검사 로직을 복붙해야 함

→ 귀찮고 실수 나옴

2. 나중에 Web API도 만들고 싶을 때
   
→ React, Spring Controller에서도 또 검증해줘야 함

3. 비즈니스 규칙 변경 시 (예: UID 규칙 변경)
   
→ UI 3~4곳에서 모든 코드를 수정해야 함

4. 단위 테스트하려고 해도
   
→ UI는 입력 기반이라 테스트가 너무 어려움

5. 그래서 UI는 절대 검증을 떠안아서는 안 된다.

## 7. 실제 대형 시스템에서는 어떻게 하는가?

### 실제로 백엔드/도메인 구조는 다음 계층 구조를 따른다:

#### Controller / UI

역할: 입력 받고, 출력하고, 흐름 제어

하지 않는 것: 검증, 비즈니스 로직, DB 연산

#### Service

역할:

- 검증 (Validation)

- 비즈니스 로직

- domain 객체 변화 조작

- Repository 호출

하지 않는 것: UI 제어, “다시 입력?” 같은 UX

 #### Repository

역할: 저장, 조회

하지 않는 것: 검증, 로직, 흐름 제어

## 8. CampusPlanner 구조에 적용하면 어떤 이점?

### 1) 기능 추가가 엄청 쉬워짐

친구/다이어리/일정/과제 등 기능을 계속 추가해도

Service 패턴만 유지하면 된다.

###  2) Android 앱으로 확장도 매우 쉬움

UI는 날리고

Service–Repository–Store만 연결하면 됨.

### 3) 입력 단계에서 모든 검증 책임이 Service로 집중

예외 케이스가 한 곳에 모여 관리가 미친 듯이 편해짐.

### 4) 테스트가 쉬워짐

Service 단일 테스트로 모든 비즈니스 규칙 테스트 가능.

5) 유지보수 비용이 50~70% 줄어듦

각 기능의 UI 코드는 짧고 단순해지고
Service는 검증/로직을 책임지므로 구조가 명확해짐.


## 9. 최종 결론 (정제된 버전)

###  FriendUI의 책임

- 사용자 입력 받기

- 재입력 흐름 처리

- 출력

- 메뉴 제어

### FriendService의 책임

- trim

- null/blank 검사

- UID 형식 검사

- UID 중복 검사

- Repository 호출

- 도메인 예외 던지기

UI는 절대 도메인 규칙을 알면 안 되고,

Service는 절대 UI 흐름을 알면 안 된다.

이 분리가 CampusPlanner 전체의 품질을 결정한다
