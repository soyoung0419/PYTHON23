# AI 활용보고서

- 사용 AI: ChatGPT 5
- 문제: 캠퍼스 플래너 콘솔 프로그램

---

### 학번: 20232002

### 이름 : 최소영

### 문제
CalendarViewModel.java - DiaryDao를 통해 일기 생성·조회·검색·수정·삭제 기능을 제공하는 뷰모델 계층

---

### 프롬프트 
diaries.get(id).orElseThrow(...) 형태로 예외 처리하는 것이 기존 Null 체크보다 더 좋은 이유가 뭐야?

---

### 결과 

좋아!
“왜 diaries.get(id).orElseThrow(...)가 기존의 null 체크보다 더 좋고,
코드 레벨에서 어떤 차이가 생기는지”를
코드 예시 + 설계 원칙 + 실제 버그 사례까지 포함해서
길고 깊게 설명해줄게.

## 1. 기존 null 체크 방식의 문제점 (나쁜 코드)

기존 코드:

```java
Diary d = diaries.get(id);
if (d == null) {
    System.out.println("일기를 찾을 수 없습니다.");
    return;
}
d.text = newText;
```

이 코드가 실제로는 매우 위험함.

### 문제 1) null을 반환한다는 사실 자체가 API 계약을 깬다

- DiaryDao.get()은 “일기를 가져온다”는 이름인데,

- 일기를 못 찾으면 null을 반환한다?

→ 메서드 이름과 반환값이 모순됨.

호출자는 다음과 같이 생각함:

“get이니까 반드시 Diary를 줄 거야”

하지만 실제로는 null이 들어올 수도 있어서…

```java
d.text = newText;  // ❌ NullPointerException 발생 가능
```

#### -> 도메인 모델의 무결성이 깨짐

### 문제 2) null 체크 누락 가능성 → 잠재적 NPE

아래처럼 null 체크를 빼먹는 버그가 매우 흔함:

```java
Diary d = diaries.get(id);
System.out.println(d.getDate());  // NPE 발생 가능
```

메서드가 null을 반환하는 순간,

프로젝트 규모가 커질수록 어디서 null을 체크해야 하는지 기억 못함.

#### -> Size가 커진 프로젝트에서 Null 버그는 가장 디버깅하기 어려운 버그 중 하나.

### 문제 3) 호출자가 null인지 아닌지 판단해야 한다 → 책임 분산(SRP 위반)

Diary가 있는지 없는지는 Dao의 책임인데,

null을 반환하면

“없음 처리” 책임이 CalendarViewModel, Handler 등 여러 곳으로 분산됨.

지저분한 코드가 생김:

```java
Diary d = diaries.get(id);
if (d == null) {
    System.out.println("없음");
    return;
}
...
```

-> DAO가 해야 할 일을 여러 컴포넌트가 떠맡게 됨
-> SRP, 응집도 감소

### 문제 4) 흐름 제어(Flow control)가 if-else로 지저분해짐

다음처럼 nested if문을 만들 가능성이 높음:

```java
Diary d = diaries.get(id);
if (d == null) {
    // ...
} else {
    if (d.text != null) {
        if (!d.text.isEmpty()) {
            d.text = newText;
        }
    }
}
```

-> 로직이 필연적으로 복잡해짐

-> 가독성 ↓ 유지보수 ↓

## 2. Optional.orElseThrow 사용한 리팩토링 코드

리팩토링 후:

```java
Diary origin = diaries.get(id)
        .orElseThrow(() -> new IllegalArgumentException("해당 ID의 일기가 없습니다: " + id));
```

###  장점 1) 의도가 코드에 명확하게 드러남

기존 null 체크 코드

```java
Diary d = diaries.get(id);
if (d == null) {
    throw new IllegalArgumentException("없음");
}
```

Optional 코드
```java
Diary d = diaries.get(id).orElseThrow(...);
```

-> "일기가 없으면 무조건 예외를 던진다"
-> 단 한 줄로 명확하게 표현됨
-> 실수하기 어려움

### 장점 2) NullPointerException을 원천 차단

- Optional을 쓰면 반드시 처리해야 한다.

- 아래 코드는 컴파일급으로 안전함:

```java
Diary d = diaries.get(id).orElseThrow(...);
d.getText();   //  절대 NPE 발생하지 않음
```

- 왜냐면:

- 저장소에 없으면 orElseThrow에서 이미 예외 발생

- 그 다음 단계로 넘어가지 않음

->  버그 차단 + 예외 흐름이 명확

### 장점 3) API 계약(Contract)이 강력해짐

DiaryDao.get()의 반환 타입이 Optional<Diary>가 되면

그 메서드는 호출자에게 이렇게 말하는 것:

“이 ID는 있을 수도 있고 없을 수도 있다. 반드시 처리해라.”

null 기반 API는 이런 말을 할 수 없음.

#### Optional은 타입 시스템에서 존재/부재를 명확히 표현하는 강력한 도구.


### 장점 4) 함수형 스타일로 로직 연결이 쉬워짐

- 기존 Null 체크 방식:
```java
Diary d = diaries.get(id);
if (d != null && d.text != null && d.text.contains(keyword)) { ... }
```

- Optional 방식:
```java
diaries.get(id)
       .map(Diary::getText)
       .filter(text -> text.contains(keyword))
       .orElseThrow(...);
```

-> 로직이 깔끔하게 “파이프”처럼 연결됨
-> 유지보수 편함

### 장점 5) SRP 만족 — 조회 실패는 Dao가 책임지도록 강제

#### CalendarViewModel:
```java
Diary origin = diaries.get(id).orElseThrow(...);
```

#### DiaryDao:

```java
public Optional<Diary> get(long id) {
    return store.diaries.stream().filter(d -> d.getId() == id).findFirst();
}
```

- Dao는 Optional을 통해 “없을 수도 있다” 강력히 표현

- ViewModel은 orElseThrow로 책임 분리 명확화

-> 응집도 증가, 결합도 감소

-> 유지보수성 증가

### 장점 6) 예외가 빠르게 발생하는 fail-fast 구조

- Null 체크는 보통 아래처럼 “늦게” 오류가 드러남:
```java
Diary d = diaries.get(id);
// ...
d.text = newText;  // 이곳에서 NPE 발생
```

- Optional.orElseThrow는 “즉시 예외” 발생:
- 
```java
Diary d = diaries.get(id).orElseThrow(...);
```

-> 오류 위치가 명확해지고

-> 버그 추적이 쉬움

## 3. 실제 CalendarViewModel 리팩토링 코드 차이 비교

### 기존 나쁜 코드 예시

```java
Diary d = diaries.get(id);
if (d == null) {
    System.out.println("없는 일기");
    return;
}
d.text = newText;
d.imagePath = img; 
// 데이터 무결성 깨질 확률 높음
```

문제:

null 체크 누락 가능

필드 직접 접근 → 캡슐화 위반

예외가 아닌 print → 호출자가 오류 처리 불가

흐름 제어 중단 불가능

### 리팩토링 후

```java
Diary origin = diaries.get(id)
        .orElseThrow(() -> new IllegalArgumentException("해당 ID의 일기가 없습니다: " + id));
```

-> 존재하지 않으면 즉시 예외

-> 정상 흐름과 예외 흐름이 깔끔하게 분리

-> CalendarViewModel 코드가 훨씬 짧고 명확해짐

## 결론 

### Optional.orElseThrow가 null 체크보다 좋은 이유

Optional.orElseThrow는 존재하지 않는 데이터를 즉시 예외로 처리하도록 강제하여,

NullPointerException을 원천적으로 차단하고,

API의 계약을 명확히 하며,

SRP/SOLID 원칙을 만족시키고,

가독성과 유지보수성을 크게 향상시키기 때문이다.


