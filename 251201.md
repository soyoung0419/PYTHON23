# AI 활용 보고서

- 사용 AI: ChatGPT 5
- 문제: 캠퍼스 플래너 콘솔 프로그램

---

### 학번: 20232002

### 이름: 최소영

### 문제
FriendHanlder.java - 콘솔 입력을 받아 친구 추가·수정·삭제·조회 등 FriendViewModel의 기능을 호출하는 UI 제어 담당 클래스이다.

---

### 프롬프트
기존 HandleFriend 코드의 거대한 switch-case 문을 더 읽기 쉽게 개선하려면 어떤 기법을 사용할 수 있을까?

---

### 결과


## 기존 코드의 거대한 switch-case 문을 더 읽기 쉽게 개선하는 기법

대규모 switch-case 문은 조건 분기와 로직이 한 곳에 뒤섞여 있어

가독성, 유지보수성, 확장성 측면에서 큰 문제를 만든다.

이 문제를 해결하기 위해 적용할 수 있는 대표적인 리팩토링 기법들은 다음과 같다.

## 1) 메서드 분리(Method Extraction) — 가장 기본적이고 효과적인 접근

switch-case의 각 분기 안에 여러 줄로 이어지는 복잡한 로직을 독립 메서드로 추출하는 방식이다.

### 적용 전 (문제 예시)
```java
switch (cmd) {
    case "a":
        System.out.print("이름: ");
        String name = sc.nextLine();
        System.out.print("UID: ");
        String uid = sc.nextLine();
        vm.add(name, uid);
        break;

    case "u":
        System.out.print("수정할 ID: ");
        long id = Long.parseLong(sc.nextLine());
        System.out.print("새 이름: ");
        String newName = sc.nextLine();
        vm.update(id, newName);
        break;

    case "d":
        System.out.print("삭제할 ID: ");
        long delId = Long.parseLong(sc.nextLine());
        vm.delete(delId);
        break;

    default:
        System.out.println("Unknown");
}
```

### 적용 후 (메서드 분리)

```java
switch (cmd) {
    case "a": addFriend(); break;
    case "u": updateFriend(); break;
    case "d": deleteFriend(); break;
    default:  System.out.println("Unknown");
}

private void addFriend() {
    System.out.print("이름: ");
    String name = sc.nextLine();
    System.out.print("UID: ");
    String uid = sc.nextLine();
    vm.add(name, uid);
}

private void updateFriend() { ... }
private void deleteFriend() { ... }
```

### 효과

- switch는 “메뉴 목록”처럼 깔끔해지고

- 실제 로직은 각각 별도의 메서드로 이동하여

- 코드 읽기, 유지보수, 테스트가 훨씬 쉬워짐

-> 지금 네가 적용한 방식이 바로 이 방식임.


## 2) 명령어 → 실행 함수 매핑(Map 기반 분기)

switch-case를 없애고, 명령 문자열을 함수로 매핑하는 방식이다.

Java의 Runnable 또는 Consumer 등을 활용한다.

### 예시 코드

```java
private final Map<String, Runnable> actions = new HashMap<>();

public FriendHandler() {
    actions.put("a", this::addFriend);
    actions.put("u", this::updateFriend);
    actions.put("d", this::deleteFriend);
}

public void run() {
    while (true) {
        String cmd = sc.nextLine().trim();
        actions.getOrDefault(cmd, this::unknownCommand).run();
    }
}
```

### 효과

- switch-case 자체가 사라짐

- 명령 추가도 map에 한 줄만 넣으면 끝

- OCP(Open-Closed Principle) 충족


## 3) Command 패턴 적용 (객체로 분기 제거)

“명령어 → Command 객체” 형태로 연결해서 실행하는 디자인 패턴이다.

### Command 인터페이스

```java
interface Command {
    void execute();
}
```

### Command들
```java
class AddCommand implements Command {
    public void execute() { /* add friend */ }
}

class UpdateCommand implements Command {
    public void execute() { /* update friend */ }
}
```

### 실행부

```java
Map<String, Command> commandMap = Map.of(
    "a", new AddCommand(),
    "u", new UpdateCommand(),
    "d", new DeleteCommand()
);

String cmd = sc.nextLine();
commandMap.getOrDefault(cmd, new Unknown()).execute();
```

### 효과

- switch-case 완전히 삭제

- 기능 추가 시 switch 문을 건드릴 필요 없음(OCP)

- 객체 지향적 확장 가능


### 4) Enum + 전략 패턴(Enum 활용 분기 제거)

Enum이 명령을 “자기 자신이 실행”하게 만드는 방식.

### 예시
```java
enum FriendCommand {
    ADD("a") {
        void execute(FriendHandler h) { h.addFriend(); }
    },
    UPDATE("u") {
        void execute(FriendHandler h) { h.updateFriend(); }
    },
    DELETE("d") {
        void execute(FriendHandler h) { h.deleteFriend(); }
    };

    private final String key;
    FriendCommand(String key) { this.key = key; }

    abstract void execute(FriendHandler h);

    static FriendCommand fromKey(String key) {
        return Arrays.stream(values())
                .filter(c -> c.key.equals(key))
                .findFirst().orElse(null);
    }
}
```

실행부:
```java
String input = sc.nextLine();
FriendCommand cmd = FriendCommand.fromKey(input);
if (cmd != null) cmd.execute(this);
else System.out.println("Unknown Command");
```

### 효과

- switch-case 없이 Enum이 행동을 관리

- 명령어 추가 → Enum 항목 추가만 하면 OK

- 타입 안정성 증가

### 5) 핸들러 클래스 분리 (책임 분할)

각 명령을 별도의 “핸들러 클래스”로 분리하는 방식.

```java
AddFriendHandler
UpdateFriendHandler
DeleteFriendHandler
```

메인 switch는 이렇게 단순화됨:
```java
switch (cmd) {
    case "a": new AddFriendHandler(vm, sc).run(); break;
    case "u": new UpdateFriendHandler(vm, sc).run(); break;
}
```
### 효과

- 로직이 클래스 단위로 분리 → SRP 충족

- 규모가 커질 때 확장성 좋음

## 결론

거대한 switch-case를 개선하는 방법 중 가장 단순하고 효과적인 것은

**메서드 분리(Method Extraction)**이며,

좀 더 나아간 구조적 개선은

Map 기반 분기, Command 패턴, Enum 전략 패턴 같은 기법을 사용할 수 있다.

네가 리팩토링한 현재 FriendHandler는

→ **메서드 분리 기법(1번)**을 가장 정확하게 적용한 형태다.

원하면
-  이 내용을 보고서용 문단으로 정리
- Before/After 비교 표
- 적용 기법의 장단점 분석
- CampusPlanner 전체 리팩토링에 적용 시의 효과
까지 만들어줄게!
