# AI 활용 보고서

- 사용 AI: Chatgpt 5
- 문제: 캠퍼스 플래너 콘솔 프로그램

---

### 학번: 20232002

### 이름 : 최소영

### 문제 
GlossaryDao.java - GlossaryEntry를 저장·조회·수정·삭제하고 검색·정렬·CSV export를 처리하는 데이터 접근 계층.

---

### 프롬프트
기존 GlossaryDao 코드의 for문 기반 조회/정렬/검색을 Java Stream API로 개선하면 어떤 장점이 있어?

---

### 결과

좋은 질문이야!

## 0. 비교 대상 정리
### 기존 나쁜 코드 예시 1 – 카테고리 조회

```java
List<GlossaryEntry> byCategory(String category) {
    List<GlossaryEntry> out = new ArrayList<>();
    for (GlossaryEntry e : store.glossary) {
        if (e.category != null && e.category.equalsIgnoreCase(category)) {
            out.add(e);
        }
    }
    return out;
}
```

### 리팩토링 후 좋은 코드 – Stream 사용

```java
public List<GlossaryEntry> byCategory(String category) {
    return store.glossary.stream()
            .filter(e -> e.getCategory() != null
                      && e.getCategory().equalsIgnoreCase(category))
            .collect(Collectors.toList());
}
```

## 1. 가독성 향상: “무슨 일을 하는지”가 바로 보인다

### 기존 for문 스타일

- 중간에 out 리스트를 선언해야 하고

- for문 안에서 if로 조건 검사하고

- 조건 통과하면 out.add(e) 하고

- 마지막에 out을 반환

- “카테고리로 필터해서 리스트를 만든다”라는 의미가 여러 줄에 흩어져 있어.
  
```java
List<GlossaryEntry> out = new ArrayList<>();
for (GlossaryEntry e : store.glossary) {
    if (e.category != null && e.category.equalsIgnoreCase(category)) {
        out.add(e);
    }
}
return out;
```

### Stream 스타일

- Stream 버전에서는 딱 한 줄로 핵심이 드러나:
  
```java
return store.glossary.stream()
        .filter(e -> e.getCategory() != null
                  && e.getCategory().equalsIgnoreCase(category))
        .collect(Collectors.toList());
```

이걸 글로 읽으면:

glossary 리스트를 stream으로 바꾸고
→ category 조건으로 filter 하고
→ 그 결과를 리스트로 collect 한다.

즉,

**“무엇을 하고 싶은지(what)”**에 집중된 코드가 되고,

**“어떻게 루프를 돌리는지(how)”**는 Stream 라이브러리가 알아서 처리해줘.

## 2. 중복 패턴 제거 + 함수형 스타일로 재사용성 증가

### 기존: 검색/카테고리별/정렬마다 비슷한 패턴 반복

예를 들어, searchByTerm 도 보면:

```java
List<GlossaryEntry> searchByTerm(String keyword) {
    List<GlossaryEntry> out = new ArrayList<>();
    if (keyword == null || keyword.isBlank()) return out;

    String kw = keyword.toLowerCase(Locale.ROOT);
    for (GlossaryEntry e : store.glossary) {
        if (e.term.toLowerCase(Locale.ROOT).contains(kw)
                || e.definition.toLowerCase(Locale.ROOT).contains(kw)) {
            out.add(e);
        }
    }
    return out;
}
```

이 패턴이 여러 메서드에 반복됨:

- new ArrayList<>() 만들고

- for 돌리고

- if로 필터링하고

- out.add()

- 마지막에 return out

### Stream: 필터/맵/정렬 같은 공통 연산 재사용

리팩토링 후:
```java
public List<GlossaryEntry> searchByTerm(String keyword) {
    if (keyword == null || keyword.isBlank()) return List.of();

    String kw = keyword.toLowerCase(Locale.ROOT);

    return store.glossary.stream()
            .filter(e -> e.getTerm().toLowerCase(Locale.ROOT).contains(kw)
                      || e.getDefinition().toLowerCase(Locale.ROOT).contains(kw))
            .collect(Collectors.toList());
}
```

장점:

- “반복문의 패턴 코드”가 사라지고 “조건만 남음”

- 필터 조건만 바꾸면 다른 검색 기능을 만들 수 있음

- filter → map → sorted → collect 같은 체이닝으로 다른 기능을 쉽게 확장 가능

예를 들어,

“카테고리 + 난이도 조건 동시 적용”을 추가하고 싶다면:
```java
public List<GlossaryEntry> searchByCategoryAndDifficulty(String category, int minDiff) {
    return store.glossary.stream()
            .filter(e -> e.getCategory() != null
                      && e.getCategory().equalsIgnoreCase(category))
            .filter(e -> e.getDifficulty() >= minDiff)
            .sorted(Comparator.comparing(GlossaryEntry::getTerm))
            .collect(Collectors.toList());
}
```

→ for문으로 짜면 다시 out = new ArrayList<>(); 부터 시작해야 하는데,
Stream은 필터를 한 줄씩 추가하면서 조합만 하면 됨.

## 3. 정렬(sorted) 코드를 더 깔끔하고 안전하게

###  기존 정렬 코드
```java
List<GlossaryEntry> sorted(String mode) {
    List<GlossaryEntry> list = getAll();
    if (mode == null) mode = "name";
    switch (mode) {
        case "recent":
            list.sort(Comparator.comparing((GlossaryEntry e) -> e.created).reversed());
            break;
        case "diff":
            list.sort(Comparator.comparingInt(e -> e.difficulty));
            break;
        case "category":
            list.sort(Comparator
                    .comparing((GlossaryEntry e) -> e.category.toLowerCase(Locale.ROOT))
                    .thenComparing(e -> e.term.toLowerCase(Locale.ROOT)));
            break;
        case "name":
        default:
            list.sort(Comparator.comparing(e -> e.term.toLowerCase(Locale.ROOT)));
            break;
    }
    return list;
}
```

- list.sort(...)를 여러 번 호출

- list가 변경 가능한(mutable) 리스트라, 혹시라도 외부에서 같은 리스트를 참조하면 부작용 발생 가능

### Stream 버전
```java
public List<GlossaryEntry> sorted(String mode) {
    if (mode == null) mode = "name";

    return store.glossary.stream()
            .sorted((a, b) -> {
                switch (mode) {
                    case "recent":
                        return b.getCreated().compareTo(a.getCreated());

                    case "diff":
                        return Integer.compare(a.getDifficulty(), b.getDifficulty());

                    case "category":
                        int c = a.getCategory().compareToIgnoreCase(b.getCategory());
                        return (c != 0) ? c :
                                a.getTerm().compareToIgnoreCase(b.getTerm());

                    case "name":
                    default:
                        return a.getTerm().compareToIgnoreCase(b.getTerm());
                }
            })
            .collect(Collectors.toList());
}
```

여기서 장점:

- 원본 리스트(store.glossary)를 직접 수정하지 않고, 정렬된 새 리스트를 반환
→ 불변성(immmutability)에 가까운 형태라 버그 줄어듦

- 정렬 기준이 Comparator 안에 모여 있어서
정렬 로직을 별도 메서드로 빼거나 테스트하기도 좋음

예를 들어 Comparator를 따로 분리하면:
```java
private Comparator<GlossaryEntry> buildComparator(String mode) {
    if (mode == null) mode = "name";
    switch (mode) {
        case "recent":
            return (a, b) -> b.getCreated().compareTo(a.getCreated());
        case "diff":
            return Comparator.comparingInt(GlossaryEntry::getDifficulty);
        case "category":
            return Comparator
                    .comparing(GlossaryEntry::getCategory, String.CASE_INSENSITIVE_ORDER)
                    .thenComparing(GlossaryEntry::getTerm, String.CASE_INSENSITIVE_ORDER);
        case "name":
        default:
            return Comparator.comparing(GlossaryEntry::getTerm, String.CASE_INSENSITIVE_ORDER);
    }
}

public List<GlossaryEntry> sorted(String mode) {
    return store.glossary.stream()
            .sorted(buildComparator(mode))
            .collect(Collectors.toList());
}
```

이러면:

- 정렬 기준 변경 시 buildComparator()만 수정하면 됨

- 단위 테스트로 각 정렬 기준을 개별적으로 검증 가능

## 4. 부작용(side-effect) 줄이기 → 버그 감소
### 기존 스타일의 문제

기존 for문 기반 코드는 대부분 이런 패턴:
```java
List<GlossaryEntry> out = new ArrayList<>();
for (GlossaryEntry e : store.glossary) {
    if (/* 조건 */) {
        out.add(e);
    }
}
return out;
```

여기에서 버그가 생기기 쉬운 포인트:

- out 대신 store.glossary에 잘못 추가하거나 삭제하는 실수

- 중간에 continue, break를 잘못 쓰면 누락/중복 가능

- 향후에 누군가 out 리스트를 다른 곳에서 또 재사용하려다가 꼬이는 경우

### Stream은 “데이터 흐름”을 한 번 정의하고 끝

```java
return store.glossary.stream()
        .filter(조건)
        .collect(Collectors.toList());
```

- filter는 새로운 Stream을 만들어줄 뿐, 원본을 수정하지 않음

- collect는 필터된 결과로 새로운 리스트만 생성

- 로컬 변수 out을 직접 조작하지 않으므로 실수 여지가 줄어듦

→ 부작용 감소 = 디버깅 시간이 줄어듦

## 5. 확장성과 테스트 용이성
### 기존 코드: 기능이 늘어날수록 if/for 지옥

예를 들어 나중에 이런 기능을 추가하고 싶다고 해보자:

- “특정 카테고리 + 난이도 3 이상 + 태그에 ‘network’ 포함”

- “최근 7일 안에 수정된 용어만 추리기”

for문으로 하면 조건문이 점점 괴물이 됨:
```java
List<GlossaryEntry> result = new ArrayList<>();
for (GlossaryEntry e : store.glossary) {
    if (e.category != null && e.category.equalsIgnoreCase(cat)
        && e.difficulty >= 3
        && e.tags != null && e.tags.contains("network")
        && e.updated.isAfter(LocalDate.now().minusDays(7))) {

        result.add(e);
    }
}
return result;
````

읽는 사람은:

“여기서 카테고리 조건이 뭔지, 난이도 조건이 뭔지, 태그 조건이 뭔지, 최근 7일 조건이 뭔지”
한 줄에 다 박혀 있어서 머리로 파싱해야 함

### Stream + 메서드 분리

예를 들어 validator/조건 메서드를 나눠서 쓰면:
```java
private boolean matchCategory(GlossaryEntry e, String cat) {
    return e.getCategory() != null
        && e.getCategory().equalsIgnoreCase(cat);
}

private boolean matchDifficultyAtLeast(GlossaryEntry e, int min) {
    return e.getDifficulty() >= min;
}

private boolean hasTag(GlossaryEntry e, String tag) {
    return e.getTags().contains(tag);
}

public List<GlossaryEntry> complexFilter(String cat) {
    return store.glossary.stream()
            .filter(e -> matchCategory(e, cat))
            .filter(e -> matchDifficultyAtLeast(e, 3))
            .filter(e -> hasTag(e, "network"))
            .filter(e -> updatedWithinDays(e, 7))
            .collect(Collectors.toList());
}
```

이러면:

- 조건을 한 줄씩 읽으면서 “아, 카테고리 → 난이도 → 태그” 순서라는 걸 바로 이해 가능

- 각 조건 메서드는 따로 단위 테스트 가능 (ex. matchCategory()만 따로 테스트)

## 6. 병렬 처리 가능성(Parallel Stream) – 미래 대비

지금은 용어 수가 얼마 안 되겠지만,
나중에 Glossary 데이터가 수천 ~ 수만 개가 될 수 있음.

기존 for문은 무조건 싱글 스레드.

Stream은 아래처럼 바꾸는 것만으로 간단히 병렬화 가능:
```java
return store.glossary.parallelStream()
        .filter(...)
        .sorted(...)
        .collect(Collectors.toList());
```

즉,
CPU 코어를 활용한 병렬 처리 준비가 이미 되어 있는 구조가 됨.
(지금 당장 쓰지 않더라도 아키텍처적으로 더 확장성이 좋다고 설명할 수 있어)

## 7. 정리: GlossaryDao에서 Stream API로 리팩토링하면서 얻은 핵심 이득

요약하면, for문 → Stream으로 바꾸면서:

- 가독성 향상

- “무엇을 하고 싶은지”가 코드에 그대로 드러남

- 필터/정렬 조건이 눈에 잘 들어옴

- 중복 패턴 제거 + 유지보수 용이

- new ArrayList, for, if, add 반복 제거

- 검색/필터/정렬 모두 같은 스타일로 통일

- 버그 가능성 감소

- 원본 컬렉션을 직접 건드리지 않고, 결과 리스트를 새로 생성

- filter/Comparator 등을 별도 메서드로 뽑아서 단위 테스트 가능

- 확장성과 병렬 처리 가능성

- 향후 요구사항 변경(조건 추가, 정렬 기준 변경)에 유연

- parallelStream()으로 쉽게 병렬 처리 전환 가능


---

# AI 활용 보고서

- 사용 AI: Cahtgpt 5
- 문제: 캠퍼스 플래너 콘솔 프로그램
---

### 학번: 20232002

### 이름: 최소영

### 문제 
GlossaryViewModel.java - 사용자 입력을 받아 GlossaryDao에게 전달하고, 검증·중복확인·수정 로직을 담당하는 비즈니스 계층.

---

### 프롬프트
null 입력, 빈 문자열 입력, 잘못된 난이도 입력이 들어올 때 어떻게 예외 처리를 해야 안정적인 구조가 될까?

---

### 결과

##  null 입력, 빈 문자열 입력, 잘못된 난이도 입력에 대한 안정적인 예외 처리 방법

GlossaryEntry와 GlossaryViewModel을 설계할 때
입력값이 잘못 들어오는 상황은 반드시 고려해야 한다.

- term = null

- term = " " (빈 문자열)

- definition = ""

- difficulty = 0, -1, 99 같은 범위 밖 숫자

- category = null / 빈 문자열

- tags = null

이런 값들이 들어와도 시스템이 오작동하지 않고,
데이터 무결성을 보장해야 한다.

## 1. “예외 처리 위치”를 올바르게 배치하는 것이 핵심

###  나쁜 구조

ViewModel이 직접 if문으로 모든 필드 검증을 처리함

```java
if (term == null || term.isBlank()) 
    throw new IllegalArgumentException("용어 없음!");
if (difficulty < 1 || difficulty > 5)
    throw new IllegalArgumentException("난이도 범위 오류!");
```

문제점:

- 중복 코드 증가

- GlossaryEntry를 다른 곳에서 생성할 때 같은 검증을 또 해야 함

- ViewModel 책임 과다 (SRP 위반)

### 좋은 구조

#### GlossaryEntry 내부에서 모든 입력값 검증 수행
#### ViewModel에서는 “올바른 객체 생성 요청만 보내기”

즉,

“객체는 스스로 유효한 상태만 유지하도록 책임진다.”
(캡슐화 + 불변성 + 도메인 검증 원칙)

## 2. null/빈 문자열/난이도 오류를 GlossaryEntry 내부에서 검증

GlossaryEntry.create() 내부에서 검증을 수행하면
ViewModel, DAO, Handler 등 여러 레이어가 반복적으로 검증할 필요가 없다.

## 3. 코드 예시 – 정적 팩토리 메서드에서의 검증 처리

### GlossaryEntry.create 내부에서 유효성 검사

```java
public static GlossaryEntry create(
        long id,
        String term,
        String definition,
        ...
) {
    validateTerm(term);
    validateDefinition(definition);
    validateDifficulty(difficulty);

    return new GlossaryEntry(
            id,
            term.trim(),
            definition.trim(),
            normalizeCategory(category),
            ...
    );
}
```

### 각 validation 메서드
```java
private static void validateTerm(String term) {
    if (term == null || term.isBlank())
        throw new IllegalArgumentException("용어(term)는 비어 있을 수 없습니다.");
}

private static void validateDefinition(String definition) {
    if (definition == null || definition.isBlank())
        throw new IllegalArgumentException("정의(definition)는 비어 있을 수 없습니다.");
}
...
```
## 4. null/빈 문자열 카테고리/태그 처리 → 정규화(normalization)

null 값을 무조건 막지 않고
적절한 기본값으로 안전하게 변환하는 것도 “예외 처리”의 일종이다.

### category = null or 빈 문자열 → null 취급

```java
private static String normalizeCategory(String c) {
    return (c == null || c.isBlank()) ? null : c.trim();
}
```
### tags = null → 빈 리스트로 치환

```java
private static List<String> normalizeTags(List<String> tags) {
    List<String> result = new ArrayList<>();
    if (tags == null) return result;

    for (String t : tags) {
        if (t != null && !t.isBlank()) {
            result.add(t.trim());
        }
    }
    return result;
}
```

- 이로써 ViewModel이나 DAO에서 null 체크 안 해도 됨.

## 5. ViewModel의 역할은 “에러 메시지 전달 + 중복 방지”에 집중

즉,

- 도메인 검증: GlossaryEntry

- 저장/조회: GlossaryDao

- UI 요청 처리: GlossaryViewModel

이 세 가지 책임이 분리된다.

### ViewModel에서는 불필요한 검증 제거
```java
public GlossaryEntry add(String term, String def, String category,
                         int difficulty, String tagInput) {

    // 중복 용어 방지 (ViewModel의 역할)
    String lower = term.toLowerCase(Locale.ROOT);
    for (GlossaryEntry e : dao.getAll()) {
        if (e.getTerm().toLowerCase(Locale.ROOT).equals(lower)) {
            throw new IllegalArgumentException("이미 존재하는 용어입니다: " + term);
        }
    }

    // 나머지 검증은 GlossaryEntry.create가 처리함
    List<String> tags = parseTags(tagInput);
    return dao.addNew(term, def, category, difficulty, tags);
}
```

## 6. 이렇게 하면 얻는 장점
### (1) 데이터 무결성 100% 보장

어디서 GlossaryEntry가 생성되든 무조건 검증됨
(다른 모듈에서 실수로 잘못 넣더라도 방지됨)

### (2) 중복 코드 제거

입력 검증이 ViewModel/DAO/Handler에 흩어지지 않고 한 곳에 집중됨

### (3) 버그 발생 가능성 최소화

null 예외, 빈 문자열 예외, 난이도 범위 예외 등
모든 오류가 한 곳에서 관리되어 유지보수 쉬워짐

### (4) SOLID 원칙 준수

- SRP: 검증 책임은 GlossaryEntry가 가짐

- OCP: 객체 내부 검증 로직이 캡슐화되어 외부 변경 최소화

- ENC: 필드 보호 및 불변성 유지

##  결론

### 안정적인 구조를 만들기 위해서는
null / 빈 문자열 / 잘못된 숫자 입력 같은 잘못된 값들을

- GlossaryEntry 생성 시점에서 검증하고

- normalize로 기본값을 안전하게 처리하며

- ViewModel에서는 오직 중복 검사·수정 요청만 수행

하는 방식이 가장 이상적이다.

이러면 전체 시스템이 오류에 강하고 유지보수도 쉬운 구조가 된다.
