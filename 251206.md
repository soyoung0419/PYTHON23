# AI 활용 보고서
- 사용 AI: ChatGPT 5
- 문제: 캠퍼스 플래너 콘솔 프로그램

---

### 학번: 20232002
### 이름: 최소영

### 문제
LocalDatabaseManager.java - LocalStore 객체를 파일로 안전하게 저장하고 다시 불러오는 역할을 담당하는 영속성 관리 클래스

---

### 프롬프트
현재 코드의 load() 메서드와 save() 메서드가 너무 많은 일을 하고 있는데, 어떻게 분리하는 것이 좋을까?

---

### 결과

## 1. 왜 분리해야 하는가? (핵심 이유)

### 문제점

현재 load()와 save()는 아래 역할을 모두 혼자서 담당하고 있음:

#### load()가 하는 일

- 파일 존재 확인

- 파일 스트림 열기

- 역직렬화 로직 처리

- 타입 검사

- 예외 처리

- 기본 객체 생성

#### save()가 하는 일

- 임시 파일 쓰기

- 직렬화

- 파일 교체(Atomic Move)

- 예외 처리

완전히 SRP(단일 책임 원칙) 위반

테스트하기 어려움

유지보수하기 어려움

코드가 길어져 가독성 저하

## 2. 어떻게 분리하는 것이 좋은가? (설계 원칙)

### 분리 기준

1. 파일 존재 여부 판단 → 별도 메서드

2. 역직렬화(Deserialize) → 전담 메서드

3. 직렬화(Serialize) → 전담 메서드

4. 파일 교체(Atomic move) → 전담 메서드

5. load()는 “최종 Store를 반환”하는 수준만 담당

6. save()는 “저장 동작을 지시하는” 수준만 담당

## 3. 실제로 어떻게 분리해야 하는지 코드로 보여줄게
### 1단계: load()를 단순하게 유지

✔ 리팩토링 후 load()
```java
public LocalStore load() {
    return readStoreFromFile()
            .orElseGet(LocalStore::new);
}
```

- load()는 이제 오직 “결과 반환”만 담당
- 실질적 파일 읽기 로직은 전부 분리

### 2단계: 파일에서 Store 읽기 로직 분리
```java
private Optional<LocalStore> readStoreFromFile() {

    if (!fileExists()) {
        return Optional.empty();
    }

    try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filePath))) {
        Object obj = ois.readObject();

        if (obj instanceof LocalStore) {
            return Optional.of((LocalStore) obj);
        }

        return Optional.empty();

    } catch (IOException | ClassNotFoundException e) {
        System.out.println("[ERROR] 로드 실패: " + e.getMessage());
        return Optional.empty();
    }
}
```

- 예외 처리 & 타입 검사도 여기서만 담당
- loadStore()가 없어도 됨 (혹은 이름만 바꿔도 됨)

### 3단계: 파일 존재 확인 분리
```java
private boolean fileExists() {
    File f = new File(filePath);
    return f.exists() && f.isFile();
}
```

- 테스트 가능성이 높아짐
- load()나 readStoreFromFile() 내부가 깔끔해짐

### 4단계: save()를 단순하게 만들기

✔ 리팩토링 후 save()
```java
public void save(LocalStore store) {
    if (store == null) return;

    try {
        writeStoreToFile(store);
    } catch (IOException e) {
        System.out.println("[ERROR] 저장 실패: " + e.getMessage());
    }
}
```

- save()가 더 이상 파일 교체, 직렬화 등의 자세한 동작을 수행하지 않음
- "저장하라"는 지시만 함 → SRP 준수

### 5단계: 직렬화 로직 분리
```java
private void writeStoreToFile(LocalStore store) throws IOException {
    try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath))) {
        oos.writeObject(store);
    }
}
```

- 직렬화 책임을 전담하는 메서드
- save()는 더 이상 직렬화를 몰라도 됨

### (선택) Atomic Move가 필요한 경우도 분리 가능
```java
private void atomicReplace(String tmp, String real) throws IOException {
    Files.move(
        Paths.get(tmp),
        Paths.get(real),
        StandardCopyOption.REPLACE_EXISTING,
        StandardCopyOption.ATOMIC_MOVE
    );
}
```

- Save 책임에서 "파일 교체" 책임을 완전히 분리
- 테스트 및 재사용 용이

## 4. 결론 — 메서드 분리 기준 

load()는 “최종 Store 반환”만 수행

아래 로직을 모두 분리:

- 파일 존재 확인

- 파일 읽기

- 역직렬화

- 타입 검사

 - 예외 처리

save()는 “저장 요청”만 수행
아래 로직을 모두 분리:

- 직렬화

- 임시 파일 생성

- 파일 교체

- 예외 처리

## 리팩토링 후 전체 구조 요약
| 기능                 | 담당 메서드              | load()에서 분리됨 | save()에서 분리됨 |
| ------------------ | ------------------- | ------------ | ------------ |
| 파일 존재 확인           | fileExists()        | ✔            |              |
| 파일 읽기              | readStoreFromFile() | ✔            |              |
| 직렬화                | writeStoreToFile()  |              | ✔            |
| 파일 교체(Atomic Move) | atomicReplace()     |              | ✔            |
| 최종 Store 반환        | load()              | 핵심 역할만 유지    |              |
| 저장 지시              | save()              |              | 핵심 역할만 유지    |
