# AI 활용 보고서

- 사용 AI:ChatGPT 5
- 문제: 캠퍼스 플래너 콘솔 프로그램

---

### 학번: 20232002

### 이름: 최소영

### 문제
DiaryHandler.java - DiaryHandler.java는 사용자 입력(UI)을 받아 일기 생성·조회·수정·삭제·검색·이미지 처리 요청을 ViewModel에 전달하는 인터페이스 역할의 콘솔 기반 핸들러

---

### 프롬프트

현재 코드에서는 UI 입력 처리와 도메인 변경 로직이 혼합되어 있는데, 이 구조의 단점과 해결 방법을 설명해줘

---

### 결과 


## UI 입력 처리와 도메인 변경 로직이 혼합된 구조의 문제점 & 해결 방안

현재 DiaryHandler 코드는 하나의 클래스에서

- 사용자 입력(UI)

- 비즈니스 로직(도메인 변경)

- 데이터 검증

- 출력 메시지 처리

가 함께 뒤섞여 있습니다.

이 구조는 처음에는 동작하는 코드로 보일 수 있지만,

장기적인 유지보수와 확장 측면에서는 심각한 문제를 야기합니다.

아래에서는 이 구조의 정확한 단점을 기술적으로 분석하고,

개선 방향과 코드 예시를 통해 더 나은 설계 방법을 제안합니다.

## 1. UI 입력 처리 + 도메인 변경 로직 혼합 구조의 문제점

### 1-1) SRP(Single Responsibility Principle) 위반

SRP(단일 책임 원칙)는

**"한 클래스는 오직 하나의 책임만 가져야 한다"**는 객체지향 설계의 핵심 규칙입니다.

하지만 기존 코드에서 DiaryHandler.run()은 다음 모두를 수행합니다.

- Switch 메뉴 출력(UI)

- 사용자 입력 처리(Scanner)

- 날짜 파싱

- 도메인 처리(ViewModel 호출)

- 예외 처리

- 조건 판단

- 결과 출력

예시 코드 (리팩토링 전)

```java
case "u":
    System.out.print("수정할 일기 ID: ");
    long uid = Long.parseLong(sc.nextLine());
    System.out.print("새 내용 (변경하지 않으려면 Enter): ");
    String newText = sc.nextLine();
    System.out.print("새 이미지 경로 (변경하지 않으려면 Enter): ");
    String newImg = sc.nextLine();
    vm.updateDiary(uid, newText, newImg.isBlank() ? null : newImg);
    System.out.println("수정 완료");
```

➡ 여기서 UI, 데이터 검증, 도메인 변경, 출력이 모두 한곳에서 이루어지고 있음.

#### 문제점

- 로직이 커질수록 가독성이 악화됨

- UI 또는 비즈니스 정책 변경 시 영향을 받는 범위가 큼

- 응집도가 낮고 결합도가 높아짐

### 1-2) 테스트 불가능한 구조

UI 입력을 요구하기 때문에

CalendarViewModel의 로직만 검증하고 싶어도

Scanner를 Mocking하거나, 실제 콘솔 입력을 시뮬레이션해야 합니다.

이로 인해 자동 단위 테스트 설계가 거의 불가능합니다.

예를 들어, 사용자가 날짜를 잘못 입력했을 때 예외가 발생하는지 검증하려면

Console input 흐름을 전부 실행해야 합니다.

### 1-3) UI 변경 시 도메인 로직까지 영향을 받음

향후 콘솔 UI를 아래처럼 바꾸고 싶다고 가정해봅시다.

- Swing GUI

- Spring MVC REST API

- Android 앱

- 웹 기반 Form

현재 구조에서는 UI가 바뀌는 순간 run() 내부 전체를 재작성해야 합니다.

즉, UI와 도메인이 강하게 결합되어 있어 재사용성이 없습니다.

### 1-4) 유지보수 난이도 증가

switch 안에서 모든 로직이 섞여 있기 때문에

수정/검색/삭제 기능을 찾기도 어렵고 일부 로직이 중복되거나 누락될 가능성이 높습니다.

코드 구조상 기능이 많아질수록 난이도는 폭발적으로 증가합니다.

### 1-5) 캡슐화 실패

UI 로직이 도메인 데이터 검증까지 수행할 경우

도메인 정책이 ViewModel 밖으로 흘러나와

Domain 객체와 ViewModel의 역할이 약화됩니다.

예:
```java
String newImg = sc.nextLine();
vm.updateDiary(uid, newText, newImg.isBlank() ? null : newImg);
```

이미지 경로가 빈 문자열일 때 null로 바꿀지 말지는 UI가 결정할 사항이 아니라 도메인 정책입니다.

이는 Domain 계층의 책임을 UI 계층이 침범한 사례입니다.

## 2. 해결 방향: UI와 도메인 로직의 명확한 분리

핵심 목표는 다음과 같습니다.

“UI Layer는 사용자 입력/출력만 담당하고

Domain Layer(ViewModel)는 데이터 처리와 검증을 전담한다.”

## 2-1) DiaryHandler는 입력/출력만 책임지게 하기

리팩토링 후 DiaryHandler는

사용자 요청을 해석하여 ViewModel에게 전달하는 라우터 역할만 수행합니다.

아래처럼 case문과 기능을 각각 메소드로 분리하고,

도메인 변경은 ViewModel에 위임합니다.

```java
private void update() {
    System.out.print("수정할 일기 ID: ");
    long id = Long.parseLong(sc.nextLine());

    System.out.print("새 내용(Enter: 유지): ");
    String newText = sc.nextLine();

    System.out.print("새 이미지 경로(Enter: 유지): ");
    String newImg = sc.nextLine();

    vm.updateDiary(id,
            newText.isBlank() ? null : newText,
            newImg.isBlank() ? null : newImg);

    System.out.println("수정 완료");
}
```

UI는 입력을 받고 Service(ViewModel)에게 정보를 던질 뿐입니다.

이로써

입력 형식, 프로토콜, UI가 어떤 방식으로 들어오든

ViewModel은 그대로 재사용 가능해집니다.

### 2-2) 도메인 검증과 데이터 변경은 ViewModel에 집중

ViewModel 내부로 검증 규칙을 이동시키는 예:

```java
public void updateDiary(long id, String newText, String newImg) {
    Diary diary = findById(id);

    if (diary == null)
        throw new IllegalArgumentException("ID가 존재하지 않습니다.");

    if (newText != null && !newText.isBlank())
        diary.changeText(newText);

    if (newImg != null)
        diary.changeImage(newImg);
}
```

중요 포인트

- UI는 null/공백 체크를 하지 않아도 됨

- 검증 규칙은 반드시 ViewModel 내부에서 통일되게 수행

- 정책 변경 시 ViewModel만 수정하면 됨

### 2-3) Domain 레벨에서 ID 기반 조회 제공

```java
public Diary findById(long id) {
    return store.diaries.stream()
            .filter(d -> d.getId() == id)
            .findFirst()
            .orElseThrow(() -> new NoSuchElementException("해당 일기 없음"));
}
```

이 메소드가 ViewModel에 존재하면

UI에서는 stream 또는 null check를 직접 하지 않아도 됩니다.

UI는 단지 이렇게 호출만 하면 됩니다:

```java
Diary diary = vm.findById(id);
ImageHelper.openImage(diary.getImagePath());
```
## 3. 최종 개선 구조

```java
[UI Layer - DiaryHandler]
- 사용자 입력
- 메뉴 출력
- 사용자가 요청한 명령을 ViewModel에게 전달

[Application/Service Layer - CalendarViewModel]
- addDiary / updateDiary / deleteDiary
- 검색, 필터, 정렬 로직
- 입력 검증, 정책 실행

[Domain Layer - Diary]
- changeText()
- changeDate()
- changeImage()
- 내부 상태 관리
```

DiaryHandler는 더 이상 도메인 정책을 알 필요가 없습니다.

사용자 입력 → VM에 전달 → 결과 출력

딱 여기까지만 하면 됩니다.

## 4. 테스트가 훨씬 쉬워짐

UI 없이 ViewModel만 테스트 가능:
```java
@Test
void testUpdateDiary() {
    CalendarViewModel vm = new CalendarViewModel();
    Diary d = vm.addDiary(LocalDate.now(), "Hello", null);

    vm.updateDiary(d.getId(), "Updated Text", null);

    Diary updated = vm.findById(d.getId());
    assertEquals("Updated Text", updated.getText());
}
```

UI 입력을 Mocking할 필요가 전혀 없습니다.

## 5. 미래 확장이 매우 쉬워짐

콘솔 UI → REST API로 변경 가능 예시

```java
@PostMapping("/diary/update")
public Diary update(@RequestBody UpdateRequest req) {
    return vm.updateDiary(req.id(), req.text(), req.img());
}
```

핸들러 UI 구조는 완전히 달라졌는데도
ViewModel은 그대로 재사용됩니다.

이게 UI/도메인 분리의 가장 강력한 장점입니다.

## 6. 결론

요소	기존 문제	리팩토링 후 효과
- 책임 분리	UI와 로직 혼재	SRP 준수
- 유지보수	정책 수정 시 UI까지 수정	Domain 레이어만 수정
- 테스트	콘솔 입력 필요 → 테스트 어려움	ViewModel 단위 테스트 가능
- 재사용성	콘솔 UI에 종속됨	API, GUI, 안드로이드 어디서든 사용 가능
- 가독성	거대 switch-case	기능별 메소드 분리
  

## 핵심 메시지

- UI Layer는 사용자 입력/출력에만 집중

- Domain Layer(ViewModel)는 모든 비즈니스 규칙을 담당

이를 통해

결합도를 낮추고 응집도를 높이며, 확장성과 재사용성을 확보할 수 있습니다.

### 필요하면 아래도 추가해줄게

- UML 클래스 다이어그램

- Handler-ViewModel 간 의사소통 시퀀스 다이어그램

- 더 실제적인 ViewModel 설계 코드

MVC/MVVM 기반 완전 구조화

언제든 말해줘!
