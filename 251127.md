---
### 학번: 20232002

### 최소영

### 문제
Diary.java - 일기의 날짜·내용·이미지 등을 보관하고 수정

---

### 프롬프트 

Diary 엔티티에서 id를 불변(final)으로 만드는 것이 어떤 이점이 있어?

---

### 결과

아주 중요한 질문이야.
Diary 엔티티에서 id를 불변(final)`로 만드는 것의 이점을 객체지향·아키텍처·DB 설계 관점에서 정리하면 아래와 같아.

## Diary 엔티티에서 id를 불변(final)로 만드는 이유 

Diary 엔티티는 “일기”라는 데이터 객체를 표현하며, **엔티티(entity)**이기 때문에 *동일성(Identity)*이 존재한다.

이 Identity를 나타내는 핵심 값이 바로 id 이다.

그리고 이 id를 final로 만들어 절대 바뀌지 않는 값으로 만들어야 하는 이유는 매우 많다.

## 1. 엔티티의 정체성을 평생 유지하기 위해 (Identity Preservation)

엔티티는 “이 객체가 무엇인가?”를 구분하는 고유 ID를 가진다.

```java
class Diary {
    private final long id;  // 엔티티의 ID, 동일성의 핵심
}
```

ID가 final이 아니라면?

```java
diary.setId(5); 
```

⬇
이 Diary 객체는 이제 완전히 다른 Diary가 되어버린다.

예:

- 원래 3번 일기였던 객체가

- 갑자기 5번 ID를 가지면

데이터의 정체성을 완전히 잃어버림.

## 2. ID가 바뀌면 저장소/DB 무결성(Data Integrity)이 붕괴한다

### 나쁜 코드 예시

```java
Diary d = repository.findById(3);
d.setId(10);   // 만약 setter가 있다면
repository.save(d);
```

➡ DB/LocalStore에는 ID 10번이 이미 존재할 수 있음

➡ 원래 ID 3 번은 삭제되지 않음

➡ 중복/충돌/유실 발생

➡ 최악의 경우, 두 개의 Diary가 같은 ID를 가지는 데이터 무결성 붕괴

## 3. ID를 변경 가능하게 두면 equals/hashCode가 망가진다

많은 엔티티는 다음과 같이 equals를 ID 기반으로 만든다:

```java
@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (!(o instanceof Diary)) return false;
    return this.id == ((Diary)o).id;
}
```

### 만약 id 변경 가능하면?'
```java
Diary diary = new Diary(3, ...);
Set<Diary> set = new HashSet<>();
set.add(diary);

diary.setId(10);  // 변경 가능하다고 가정
```

➡ HashSet 내부에서 원래 버킷 위치를 잃어버림

➡ set.contains(diary) == false

➡ set.remove(diary) == false

➡ 즉, 컬렉션 일관성 붕괴 + 메모리 누수 위험

#### final id일 경우

ID가 절대 변하지 않으므로 equals/hashCode 문제 없음.


## 4. Repository(Dao)가 ID 생성을 책임지기 때문에 final이 맞다

좋은 Diary 설계는 다음 구조임:

```java
ViewModel → DiaryDao → Diary (ID 부여는 DAO)
```

### Diary 생성 시

```java
Diary draft = new Diary(0, date, text, imagePath);
Diary saved = diaryDao.saveNew(draft);  // saveNew에서 ID 생성
```

ID는 DAO에서 생성하는 값이므로,

Diary 객체는 한 번 부여된 ID를 변경할 이유가 아예 없다.

### ID setter가 있으면?

- ViewModel이 임의로 ID 바꿀 수 있음

- UI Handler에서 ID 변조 가능

- 사용자 입력으로 ID를 바꿔버리는 일도 발생

➡ DAO의 책임이 완전히 무너짐.

## 5. 엔티티의 “상태 변경”과 “정체성”을 분리할 수 있다

### Diary 엔티티는 다음과 같은 “변하는 데이터”를 가진다:

- text

- date

- imagePath

하지만 id만큼은 평생 유지되는 불변 필드여야 한다.

즉:

- 변경되는 값: 내용·이미지·날짜

- 변경되지 않는 값: ID

이 구조가 객체지향에서 엔티티 모델링의 기본 철학이다.

## 6. 불변성이 버그를 줄이고 개발을 단순하게 한다

변경 가능한 객체는 항상 "현재 상태가 무엇인가?"를 추적해야 한다.

### 하지만 ID가 바뀌지 않으면:

- 디버깅 쉬움

- 로그 분석 쉬움

- 비즈니스 규칙 단순화

- ViewModel/DAO 개발 쉬움

특히, 운영 로그에서 다음과 같은 로그 분석이 쉽다:

```java
[Diary#32] 이미지 변경
[Diary#32] 내용 수정
[Diary#32] 날짜 변경
```

ID가 불변이 아니었다면 로그조차 믿을 수 없다.

## 7. ID 변경 가능은 실무에서 매우 위험하다고 분류된다

### 실무에서는 “ID를 setter로 만들어 두면 안 되는 클래스들의 목록”이 있다.

- User id

- 게시글 id

- Diary id

- Article id

Order id

- Product id

### 이들을 setter로 두면:

- 보안 이슈

- 서버 간 동기화 문제

- 중복키 충돌

- 거래 데이터 오류

등이 발생한다.

그래서 ID는 항상 final 또는 read-only로 두는 것이 정석이다.


## 8. 나쁜 코드 vs 좋은 코드 비교 예시

### 나쁜 코드 (ID 변경 가능)

```java
public class Diary {
    private long id;  
    // ...
    public void setId(long id) {
        this.id = id;
    }
}
```

#### 문제점:

- 누구나 id 변경 가능

- Repository 정책 붕괴

- 동일성 붕괴

- equals/hashCode 문제

### 좋은 코드 (ID 불변)

```java
public class Diary {
    private final long id;
    private LocalDate date;
    private String text;
    private String imagePath;

    public Diary(long id, LocalDate date, String text, String imagePath) {
        this.id = id;
        this.date = date;
        this.text = text;
        this.imagePath = imagePath;
    }
}
```

#### 이점:

- 동일성 보장

- 무결성 보장

- 저장 정책 안정

- 리팩토링 쉬움

- 테스트 쉬움

## 최종 요약

### Diary의 ID가 final이어야 하는 이유는 다음과 같다:


| 항목 | 설명 |
|------|------|
| **엔티티 동일성 보존** | id가 바뀌면 Diary 자체가 다른 일기가 되어버림 |
| **DB/저장소 무결성 유지** | 중복 ID, 충돌, 데이터 손상 막음 |
| **equals/hashCode 안정성** | 컬렉션(Set/Map)에서 안정적으로 동작 |
| **Repository 정책 유지** | ID 생성 책임이 DAO에 있으므로 변경 금지 |
| **변경 가능한 값과 정체성 분리** | Text/date는 바뀌어도 ID는 고정 |
| **버그 감소 + 유지보수성 향상** | 불변 필드는 디버깅이 훨씬 쉬움 |
| **실무 관행 및 보안** | 모든 엔티티의 id는 불변으로 관리하는 것이 표준 |

---

### 문제 
DairyDao.java - 일기(Diary) 데이터를 저장·조회·수정·삭제하기 위한 저장소 접근 기능을 추상화한 인터페이스

---

### 프롬프트 

Optional 반환을 사용하는 것이 기존 null 반환 대비 어떤 장점이 있어?

---

### 결과

아주 좋은 질문이고, Repository(DAO) 설계에서 Optional을 쓰는 이유는 매우 중요해.
여기서 null 반환 vs Optional 반환의 차이를 개념적으로 + 실무적으로 + 코드 예시까지 자세히 정리해줄게.

## 1. NPE(NullPointerException) 위험을 “타입 수준”에서 줄인다

###  null 반환 방식의 근본 문제

null 반환 방식은 사용 코드가 이렇게 되기 쉽다:

```java
Diary d = diaryDao.findById(10); // null 가능

System.out.println(d.getText()); // 여기서 NPE 가능
```

- findById()가 null을 반환할 수 있다는 건 주석으로만 알 수 있음.

- 개발자가 null 체크를 깜빡하면 바로 런타임 예외(NPE) 발생.

- 특히 규모가 큰 프로젝트에서는, “누가 null 체크를 했는지/안 했는지”를 전부 추적하기 어려움.

### Optional 반환 방식

```java
Optional<Diary> opt = diaryDao.findById(10);

opt.ifPresent(d -> System.out.println(d.getText()));
```

여기서 중요한 포인트:

- Optional<Diary> 타입 자체가 “값이 없을 수도 있음”을 강제적으로 보여줌

- 컴파일 타임에 Diary가 아니라 Optional<Diary>이기 때문에,
실수로 바로 getText()를 호출할 수 없음

```java
// 컴파일 에러
diaryDao.findById(10).getText(); 
```

-  “값이 없을 수도 있다”는 리스크를 타입에 반영해서, 컴파일러가 강제로 의식시키는 효과가 있음.

## 2. 메서드의 “의도”가 훨씬 명확해진다

###  null 반환 시 문제

```java
Diary findById(long id);
```

이 메서드를 보는 사람은 이렇게 생각해야 함:

- 못 찾으면 예외 던지나?

- 못 찾으면 null을 주나?

- null이 정상 케이스인가? 에러 케이스인가?

- 주석 안 보면 정확히 알기 어렵다.

### Optional 반환 시 명확성

```java
Optional<Diary> findById(long id);
```

이 한 줄로 다음이 모두 드러난다:

- 이 메서드는 “Diary가 있을 수도 있고 없을 수도 있다”

- “없다”는 상황이 정상적인 시나리오로 고려되어 있다

- 호출자는 반드시 이 두 경우를 처리해야 한다

#### 이는 API를 보는 사람 입장에서는 매우 큰 정보다.
**“이 메서드는 실패 가능성이 있다”**라는 것이 타입에 드러난다는 게 포인트.

## 3. Optional은 “값이 없음”을 표현하는 전용 타입이다

### null은 의미가 너무 많다:

- 아직 초기화 안 됨

- 로직에 의해 일부러 null 넣음

- DAO가 값을 못 찾음

- 개발자가 실수로 넣지 않음

- 즉, null 하나에 너무 많은 의미가 섞여 있음.

### 반면 Optional.empty()는:

- “여기에는 값이 없다(no value)”를 명시적으로 표현

- 그리고 그 상태를 다루기 위한 다양한 메서드를 제공

예를 들어:

```java
Optional<Diary> opt = diaryDao.findById(10);

Diary d = opt.orElseGet(() -> createDefaultDiary());
```

여기서:

- 값이 있으면 그 값을 쓰고

- 값이 없으면 createDefaultDiary() 호출해 기본 Diary 생성

이런 패턴은 null로는 표현하기 훨씬 복잡해짐.

## 4. 호출 측 코드가 “안전한 스타일”로 유도된다

Optional을 반환하면, 호출 측이 자연스럽게 이렇게 코딩하게 된다:

### 1.  orElseThrow 패턴

```java
Diary d = diaryDao.findById(id)
        .orElseThrow(() -> new IllegalArgumentException("해당 ID의 일기가 없습니다."));
```

- 값이 없을 때 오류로 처리할지,

- 그냥 무시할지,

- 기본값을 쓸지

를 호출하는 쪽에서 명확하게 선택할 수 있음.

### 2.  ifPresent 패턴

```java
diaryDao.findById(id)
        .ifPresent(diary -> {
            System.out.println("일기 내용: " + diary.getText());
        });
```

값이 있을 때만 행동을 수행 → null 체크를 깜빡할 여지가 줄어듦.

## 5. DAO 구현 코드와 잘 어울린다 (stream, findFirst와 자연스럽게 연결)

LocalStore 기반 구현을 보면 보통 이렇게 짠다:

```java
@Override
public Optional<Diary> findById(long id) {
    return store.diaries.stream()
            .filter(d -> d.getId() == id)
            .findFirst(); // 이미 Optional<Diary> 반환
}
```

findFirst()가 반환하는 타입이 이미 Optional<Diary>라서:

- 굳이 null로 바꿨다가,

- 다시 사용하는 쪽에서 null 체크를 하게 만들 필요가 없음

“없음”이라는 상태를 이미 Optional로 잘 표현하고 있으니까,
그걸 그대로 인터페이스까지 끌고 올라오는 게 자연스러운 설계야.

## 6. 테스트 코드도 더 깔끔해진다

###  null 반환 방식 테스트

```java
Diary found = diaryDao.findById(1L);
assertNotNull(found);

Diary notFound = diaryDao.findById(999L);
assertNull(notFound);
```

- assertNull/assertNotNull은 실수하기 쉽고 의미도 애매하다

### Optional 방식 테스트
```java
assertTrue(diaryDao.findById(1L).isPresent());
assertTrue(diaryDao.findById(999L).isEmpty());
```

- 테스트 내용이 “값 존재 여부”와 직관적으로 딱 맞음

- isPresent / isEmpty 자체가 의미를 그대로 드러냄

## 7. 실무/이론적으로도 인증된 패턴이다

- 《Effective Java》에서 “가능하면 null 대신 Optional을 사용하라”는 항목이 있을 정도

- Spring Data JPA의 findById()도 Optional 반환:
```java
Optional<User> findById(Long id);
```

- Kotlin, Swift 같은 언어는 아예 Nullable / Optional을 언어 레벨에서 구분

 - 즉, “값이 없을 수도 있는 경우를 Optional로 감싸는 설계”는
트렌드가 아니라 이미 표준이 된 패턴이다.

## 8. DiaryDao에 Optional을 쓰는 게 구체적으로 어떤 이점이 있었는지

우리 상황에 딱 맞춰서 정리하면:
```java
public interface DiaryDao {

    Optional<Diary> findById(long id);
    List<Diary> findAll();
    List<Diary> findByDate(LocalDate date);

    Diary saveNew(Diary diary);
    Diary save(Diary diary);
    void delete(long id);
}
```
### ViewModel 코드에서 장점:
```java
public void updateDiary(long id, String newText, String newImagePath) throws Exception {
    Diary d = repository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("해당 ID의 일기가 없습니다."));

    d.changeText(newText);
    // ...
    repository.save(d);
}
```

- 더 이상 if (d == null) 같은 코드 없음

- “존재하지 않으면 예외로 처리한다”는 정책이 코드에 딱 보임

- 흐름이 직관적이고, 버그 날 여지가 적어짐

## 9. null을 그대로 쓰는 것이 특히 위험한 경우들

1. 리팩토링 시

- 기존에는 항상 값이 있었다가,

- 이후 “없을 수도 있는 경우”가 생기면

- 호출자 수십 군데에 null 체크를 추가해야 함

2. 협업 시

- 어떤 사람은 null을 반환

- 어떤 사람은 예외 던짐

- 어떤 사람은 빈 객체 반환…
→ API 사용 방법이 통일되지 않음

3. 코드 베이스가 커질수록

- “여기서는 null이 올 수도 있는지?”

- “이 메서드는 null 반환 가능성이 있는지?”
계속 추적해야 함 → 정신 피곤해짐

- Optional은 이 모든 것을 타입 한 줄로 명확하게 잡아준다.

## 최종 요약

### Optional 반환을 쓰면, null 반환 대비 다음과 같은 큰 장점이 있다:

1. NPE 위험을 줄이고, 컴파일 타임에 리스크를 드러낸다

2. “값이 없을 수도 있음”을 타입에 표현해, 메서드 의도를 명확히 한다

3. Optional.empty()로 의도된 '값 없음' 상태를 모델링할 수 있다

4. orElse, ifPresent, orElseThrow 등 유틸 메서드로 깔끔한 처리 패턴을 만든다

5. DAO 구현(stream, findFirst)과도 자연스럽게 맞아떨어진다

6. 테스트 코드에서도 값 존재 여부를 직관적으로 검증할 수 있다

7. Effective Java, Spring, 최신 언어들이 이미 채택한 표준 패턴이다

