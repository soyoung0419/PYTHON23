---
### 학번: 20232002

### 최소영

### 문제
Diary.java - 일기의 날짜·내용·이미지 등을 보관하고 수정

---

### 프롬프트 

Diary 엔티티에서 id를 불변(final)으로 만드는 것이 어떤 이점이 있어?

---

### 결과

아주 중요한 질문이야.
Diary 엔티티에서 id를 불변(final)`로 만드는 것의 이점을 객체지향·아키텍처·DB 설계 관점에서 정리하면 아래와 같아.

## Diary 엔티티에서 id를 불변(final)로 만드는 이유 

Diary 엔티티는 “일기”라는 데이터 객체를 표현하며, **엔티티(entity)**이기 때문에 *동일성(Identity)*이 존재한다.

이 Identity를 나타내는 핵심 값이 바로 id 이다.

그리고 이 id를 final로 만들어 절대 바뀌지 않는 값으로 만들어야 하는 이유는 매우 많다.

## 1. 엔티티의 정체성을 평생 유지하기 위해 (Identity Preservation)

엔티티는 “이 객체가 무엇인가?”를 구분하는 고유 ID를 가진다.

```java
class Diary {
    private final long id;  // 엔티티의 ID, 동일성의 핵심
}
```

ID가 final이 아니라면?

```java
diary.setId(5); 
```

⬇
이 Diary 객체는 이제 완전히 다른 Diary가 되어버린다.

예:

- 원래 3번 일기였던 객체가

- 갑자기 5번 ID를 가지면

데이터의 정체성을 완전히 잃어버림.

## 2. ID가 바뀌면 저장소/DB 무결성(Data Integrity)이 붕괴한다

### 나쁜 코드 예시

```java
Diary d = repository.findById(3);
d.setId(10);   // 만약 setter가 있다면
repository.save(d);
```

➡ DB/LocalStore에는 ID 10번이 이미 존재할 수 있음

➡ 원래 ID 3 번은 삭제되지 않음

➡ 중복/충돌/유실 발생

➡ 최악의 경우, 두 개의 Diary가 같은 ID를 가지는 데이터 무결성 붕괴

## 3. ID를 변경 가능하게 두면 equals/hashCode가 망가진다

많은 엔티티는 다음과 같이 equals를 ID 기반으로 만든다:

```java
@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (!(o instanceof Diary)) return false;
    return this.id == ((Diary)o).id;
}
```

### 만약 id 변경 가능하면?'
```java
Diary diary = new Diary(3, ...);
Set<Diary> set = new HashSet<>();
set.add(diary);

diary.setId(10);  // 변경 가능하다고 가정
```

➡ HashSet 내부에서 원래 버킷 위치를 잃어버림

➡ set.contains(diary) == false

➡ set.remove(diary) == false

➡ 즉, 컬렉션 일관성 붕괴 + 메모리 누수 위험

#### final id일 경우

ID가 절대 변하지 않으므로 equals/hashCode 문제 없음.


## 4. Repository(Dao)가 ID 생성을 책임지기 때문에 final이 맞다

좋은 Diary 설계는 다음 구조임:

```java
ViewModel → DiaryDao → Diary (ID 부여는 DAO)
```

### Diary 생성 시

```java
Diary draft = new Diary(0, date, text, imagePath);
Diary saved = diaryDao.saveNew(draft);  // saveNew에서 ID 생성
```

ID는 DAO에서 생성하는 값이므로,

Diary 객체는 한 번 부여된 ID를 변경할 이유가 아예 없다.

### ID setter가 있으면?

- ViewModel이 임의로 ID 바꿀 수 있음

- UI Handler에서 ID 변조 가능

- 사용자 입력으로 ID를 바꿔버리는 일도 발생

➡ DAO의 책임이 완전히 무너짐.

## 5. 엔티티의 “상태 변경”과 “정체성”을 분리할 수 있다

### Diary 엔티티는 다음과 같은 “변하는 데이터”를 가진다:

- text

- date

- imagePath

하지만 id만큼은 평생 유지되는 불변 필드여야 한다.

즉:

- 변경되는 값: 내용·이미지·날짜

- 변경되지 않는 값: ID

이 구조가 객체지향에서 엔티티 모델링의 기본 철학이다.

## 6. 불변성이 버그를 줄이고 개발을 단순하게 한다

변경 가능한 객체는 항상 "현재 상태가 무엇인가?"를 추적해야 한다.

### 하지만 ID가 바뀌지 않으면:

- 디버깅 쉬움

- 로그 분석 쉬움

- 비즈니스 규칙 단순화

- ViewModel/DAO 개발 쉬움

특히, 운영 로그에서 다음과 같은 로그 분석이 쉽다:

```java
[Diary#32] 이미지 변경
[Diary#32] 내용 수정
[Diary#32] 날짜 변경
```

ID가 불변이 아니었다면 로그조차 믿을 수 없다.

## 7. ID 변경 가능은 실무에서 매우 위험하다고 분류된다

### 실무에서는 “ID를 setter로 만들어 두면 안 되는 클래스들의 목록”이 있다.

- User id

- 게시글 id

- Diary id

- Article id

Order id

- Product id

### 이들을 setter로 두면:

- 보안 이슈

- 서버 간 동기화 문제

- 중복키 충돌

- 거래 데이터 오류

등이 발생한다.

그래서 ID는 항상 final 또는 read-only로 두는 것이 정석이다.


## 8. 나쁜 코드 vs 좋은 코드 비교 예시

### 나쁜 코드 (ID 변경 가능)

```java
public class Diary {
    private long id;  
    // ...
    public void setId(long id) {
        this.id = id;
    }
}
```

#### 문제점:

- 누구나 id 변경 가능

- Repository 정책 붕괴

- 동일성 붕괴

- equals/hashCode 문제

### 좋은 코드 (ID 불변)

```java
public class Diary {
    private final long id;
    private LocalDate date;
    private String text;
    private String imagePath;

    public Diary(long id, LocalDate date, String text, String imagePath) {
        this.id = id;
        this.date = date;
        this.text = text;
        this.imagePath = imagePath;
    }
}
```

#### 이점:

- 동일성 보장

- 무결성 보장

- 저장 정책 안정

- 리팩토링 쉬움

- 테스트 쉬움

## 최종 요약

### Diary의 ID가 final이어야 하는 이유는 다음과 같다:


| 항목 | 설명 |
|------|------|
| **엔티티 동일성 보존** | id가 바뀌면 Diary 자체가 다른 일기가 되어버림 |
| **DB/저장소 무결성 유지** | 중복 ID, 충돌, 데이터 손상 막음 |
| **equals/hashCode 안정성** | 컬렉션(Set/Map)에서 안정적으로 동작 |
| **Repository 정책 유지** | ID 생성 책임이 DAO에 있으므로 변경 금지 |
| **변경 가능한 값과 정체성 분리** | Text/date는 바뀌어도 ID는 고정 |
| **버그 감소 + 유지보수성 향상** | 불변 필드는 디버깅이 훨씬 쉬움 |
| **실무 관행 및 보안** | 모든 엔티티의 id는 불변으로 관리하는 것이 표준 |
