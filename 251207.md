# AI 활용 보고서
- 사용 AI: ChatGPT 5
- 문제: 캠퍼스 플래너 콘솔 프로그램

---

### 학번: 20232002
### 이름: 최소영

### 문제
DiaryDao.java - 

---

### 프롬프트
Crud 인터페이스가 기존 Crud<T>에서 식별자 타입을 분리한 Crud<T, ID> 형태로 변경되었는데, 이 경우 DiaryDao에서는 ID 타입을 Long으로 고정해서 사용해도 괜찮아?

---

### 결과


## Crud<T>에서 Crud<T, ID> 구조로 변경된 후 DiaryDao에서 ID를 Long으로 고정해도 되는가?

Crud 인터페이스가 기존의 Crud<T>에서 Crud<T, ID>로 확장되었다는 것은,

모든 DAO 클래스가 도메인 객체와 그 객체의 식별자 타입을 명확하게 분리하여

유연하게 사용할 수 있도록 설계되었다는 의미이다.

즉, 기존에는 CRUD 인터페이스 내부에서 ID 타입을 long으로 고정하고 있었기 때문에

DAO 개발 시 ID 타입을 신경 쓸 필요가 없었다. 하지만 이제는 다음과 같이

ID를 외부에서 직접 지정해주어야 한다.
```java
public interface Crud<T, ID> {
    T add(T entity);
    Optional<T> get(ID id);
    List<T> getAll();
    Optional<T> update(T entity);
    boolean delete(ID id);
}
```

그렇다면 DiaryDao에서는 ID 타입을 Long으로 고정해도 되는지,

혹은 DiaryDao 자체를 제네릭으로 설계해야 하는지 검토가 필요하다.

## 1. DiaryDao는 ID 타입을 Long으로 고정해도 전혀 문제가 없다

Diary 엔티티를 살펴보면, ID 타입이 이미 long으로 설계되어 있다:
```java
public class Diary implements Serializable {
    private final long id;
    private LocalDate date;
    private String text;
    private String imagePath;

    public long getId() { return id; }
}
```

즉, 도메인 모델이 long 기반 ID 사용을 명확히 규정하고 있다.

이 말은 DiaryDao가 유연한 ID 타입을 받을 필요가 전혀 없다는 뜻이다.

따라서 다음과 같은 형태로 DiaryDao를 선언하는 것이 완전히 자연스럽고 올바르다:
```java
public class DiaryDao implements Crud<Diary, Long> {
    private final LocalStore store;
    private final LocalDatabaseManager db;

    public DiaryDao(LocalStore store, LocalDatabaseManager db) {
        this.store = store;
        this.db = db;
    }

    @Override
    public Diary add(Diary diary) {
        store.diaries.add(diary);
        persist();
        return diary;
    }

    @Override
    public Optional<Diary> get(Long id) {
        return store.diaries.stream()
                .filter(d -> d.getId() == id)
                .findFirst();
    }

    @Override
    public List<Diary> getAll() {
        return new ArrayList<>(store.diaries); // 방어적 복사
    }

    @Override
    public Optional<Diary> update(Diary updated) {
        Diary origin = get(updated.getId())
                .orElseThrow(() -> new IllegalArgumentException("Not found"));

        origin.updateText(updated.getText());
        origin.changeImagePath(updated.getImagePath());
        persist();
        return Optional.of(origin);
    }

    @Override
    public boolean delete(Long id) {
        Optional<Diary> target = get(id);
        if (target.isEmpty()) return false;

        store.diaries.remove(target.get());
        persist();
        return true;
    }

    private void persist() {
        db.save(store);
    }
}
```

이처럼 DAO 구현부가 ID 타입에 의존적이긴 하지만,

그 의존성이 **도메인 자체가 결정한 타입(Long)**에 기반하고 있으므로 자연스러운 의존성이다.

## 2. DiaryDao 자체를 제네릭 클래스로 만들 필요는 없다

일부 경우 다음과 같은 설계도 가능하다:
```java
public class DiaryDao<ID> implements Crud<Diary, ID> {
}
```

또는:
```java
public class GenericDao<T, ID> implements Crud<T, ID> { ... }
public class DiaryDao extends GenericDao<Diary, Long> { ... }
```

하지만 DiaryDao는 Diary에만 특화된 DAO이며, 다음과 같은 Diary 특화 기능을 포함한다:

- 이미지 파일 삭제 처리

- 날짜 데이터 검증

- 텍스트 내용 업데이트

- 도메인 규칙(예: 날짜 변경 불가 조건 등)

이러한 로직은 Diary 엔티티에 강하게 종속되므로,

DiaryDao를 제네릭으로 확장하면 책임이 불필요하게 분산되고 복잡성만 증가하게 된다.

즉,

DiaryDao는 Diary 전용 DAO이므로, ID 타입까지 유동적으로 받을 필요는 없다.

오히려 구체 타입(Concrete Type)을 명확히 하는 것이 설계적으로 더 안정적이다.

## 3. 만약 나중에 ID 타입을 변경하고 싶다면?

Diary의 ID 타입을 long에서 UUID로 바꾸고 싶다면,

Diary 객체 자체가 변경되어야 하기 때문에 다음과 같은 선언만 수정하면 된다:

```java
public class DiaryDao implements Crud<Diary, UUID> { ... }
```

즉, DiaryDao를 제네릭으로 만들지 않더라도 확장성은 그대로 유지된다.

## 최종 결론

DiaryDao에서는 ID 타입을 Long으로 고정해도 전혀 문제가 없으며 오히려 가장 바람직한 설계이다.

Diary 엔티티 자체가 long 기반 ID를 사용하고 있고, DiaryDao는 Diary에 특화된 구체 DAO이므로

ID 타입을 외부에서 제네릭으로 받을 이유도, 구조적으로 받아야 할 필요도 없다.

따라서 아래 선언이 정답이다:
```java
public class DiaryDao implements Crud<Diary, Long>
```
