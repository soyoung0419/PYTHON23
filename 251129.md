# AI 활용보고서

- 사용 AI: ChatGPT 5
- 문제: 캠퍼스 플래너 콘솔 프로그램

---

### 학번: 20232002

### 이름 : 최소영

### 문제

ImageHelper.java - 이미지 파일을 저장·열기·삭제하는 기능을 제공하는 유틸리티 클래스

---

### 프롬프트

기존 코드 randomName 내에 있는 파일 확장자 추출 로직을 별도 메서드로 분리하면 어떤 장점이 있는지 설명해줘

---

### 결과


좋은 질문이야!

아래는 기존 ImageHelper.randomName() 안에 있던 확장자 추출 로직을 별도 메서드로 분리했을 때의 장점을 정확히 짚어서 정리한 설명이야.


## 0. 전제 – 기존 코드 vs 리팩토링 코드

### 리팩토링 전(randomName 내부에 확장자 처리 포함)

```java
static String randomName(String originalName) {
    String ext = "";
    int idx = originalName.lastIndexOf(".");
    if (idx != -1) ext = originalName.substring(idx);
    return UUID.randomUUID().toString() + ext;
}
```

### 리팩토링 후(확장자 추출을 별도 메서드로 분리)

```java
// 1) 확장자만 추출하는 메서드
private static String extractExtension(String name) {
    if (name == null) return "";
    int idx = name.lastIndexOf(".");
    return (idx == -1) ? "" : name.substring(idx);
}

// 2) 랜덤 파일 이름 생성
private static String randomFileName(String original) {
    String ext = extractExtension(original);
    return UUID.randomUUID().toString() + ext;
}
```

즉, 기존에는 randomName()이 “확장자 추출 + UUID 생성”을 동시에 했는데,

리팩토링 후에는 “확장자 추출(extractExtension)”과 “랜덤 이름 생성(randomFileName)”이 역할을 나누어 맡게 된 것이 핵심이야.

## 1. 단일 책임 원칙(SRP) 관점에서의 장점

### 1) 리팩토링 전 – 하나의 메서드가 두 가지 역할 수행

```java
static String randomName(String originalName) {
    // (1) 확장자 추출 역할
    String ext = "";
    int idx = originalName.lastIndexOf(".");
    if (idx != -1) ext = originalName.substring(idx);

    // (2) 랜덤 파일명 생성 역할
    return UUID.randomUUID().toString() + ext;
}
```

이 메서드는:

- “파일 이름에서 확장자를 뽑아낸다.”

- “UUID로 랜덤 이름을 만든다.”

- 즉, 두 가지 책임을 동시에 가지고 있어.

- 나중에 “확장자 처리 방식”만 바꾸고 싶어도 randomName()을 뜯어고쳐야 해.


### 2) 리팩토링 후 – 책임이 명확하게 분리

```java
private static String extractExtension(String name) {
    if (name == null) return "";
    int idx = name.lastIndexOf(".");
    return (idx == -1) ? "" : name.substring(idx);
}

private static String randomFileName(String original) {
    String ext = extractExtension(original);
    return UUID.randomUUID().toString() + ext;
}
```

- extractExtension : **“파일 이름 → 확장자 문자열”**만 담당

- randomFileName : **“랜덤 파일 이름 생성”**만 담당
(확장자 처리 세부 로직은 신경 쓰지 않음)

-> SRP(단일 책임 원칙) 관점에서 볼 때,

각 메서드가 “딱 한 가지 일만 하는 구조”가 돼서

이해하기도 쉽고, 변경 범위도 줄어들어.

## 2. 재사용성(Reuse) 증가

확장자 추출 로직은 랜덤 이름 만들 때만 필요한 게 아니야. 

### 예를 들어:

- 이미지 파일 업로드 시,

- “허용 확장자인지 검사해야 할 때” (.jpg/.png만 허용 등)

- 로그를 찍을 때 “파일명과 확장자를 분리해서 보여주고 싶을 때”

### 향후:

- 썸네일 생성 기능

- 파일 미리보기 기능

- 백업/복원 기능 등

이때 확장자 추출 코드가 randomName() 안에 박혀 있으면

재사용하려면 똑같은 로직을 또 작성해야 해.

### 하지만 이렇게 되어 있으면:

```java
String ext = extractExtension(fileName);
```

어디서든 한 줄로 가져다 쓸 수 있음.

즉,

“확장자 추출”은 도메인에서 꽤 자주 쓰이는 공통 로직이기 때문에 별도의 메서드로 빼는 게 재사용 측면에서 훨씬 합리적이야.


## 3. 유지보수성(Maintainability) 향상

### 상황 가정

나중에 요구사항이 바뀐다고 해보자:

1. .jpeg → .jpg로 통일해서 저장해야 한다.

2. 확장자가 없으면 .png를 기본으로 붙여야 한다.

3. .tar.gz처럼 복잡한 확장자를 처리해야 한다.

4. 대문자 확장자(.PNG)도 모두 소문자로 변환해야 한다.

이런 요구사항이 생겼을 때, 리팩토링 후 구조에서는:

```java
private static String extractExtension(String name) {
    if (name == null) return "";

    int idx = name.lastIndexOf(".");
    if (idx == -1) {
        // 확장자 없는 경우 기본값
        return ".png";
    }

    String ext = name.substring(idx).toLowerCase(Locale.ROOT);

    if (ext.equals(".jpeg")) {
        return ".jpg";
    }

    return ext;
}
```

- 이 메서드 하나만 수정하면 전체 동작이 바뀜.

- 랜덤 파일명 만드는 로직, 이미지 저장 로직 등은 손댈 필요 없음.

반대로, 확장자 추출이 randomName()에 박혀 있고,

다른 곳에서도 비슷한 코드를 복붙해서 쓰고 있었다면?

- 여러 곳을 동시에 수정해야 하고

- 하나라도 빼먹으면 버그가 됨

- “어디 어디에 비슷한 로직이 있는지” 찾는 것도 고역

➡ 확장자 처리 정책이 바뀌었을 때 변경 지점이 한 곳으로 모이도록 만드는 게
리팩토링의 핵심 장점 중 하나야.

## 4. 가독성(Readability) 향상

### 리팩토링 전 코드를 처음 보는 사람 입장에서 보면:

```java
String ext = "";
int idx = originalName.lastIndexOf(".");
if (idx != -1) ext = originalName.substring(idx);
return UUID.randomUUID().toString() + ext;
```

- “아, 여기서 점의 위치를 찾네? 그다음 substring? 아, 확장자 뽑는 거구나…”

- 의미를 이해하려면 구현 세부 내용을 따라가야 함


### 리팩토링 후에는:

```java
String ext = extractExtension(original);
return UUID.randomUUID().toString() + ext;
```

- extractExtension()이라는 이름에서 이미 의도가 드러남.

- 구현을 보지 않고도 / 한 번만 봐도 무슨 역할인지 바로 이해 가능.

- 즉, “코드를 읽는 사람의 뇌 사용량을 줄여주는 것”도 중요한 개선점이야.


## 5. 테스트 용이성(Testability) 증가

테스트 관점에서 이 차이는 더 크게 느껴져.

### 1) 리팩토링 전 – randomName만 있음

```java
randomName("dog.png") → "무작위UUID.png"
```

#### 문제:

- UUID가 매번 바뀌기 때문에 결과 문자열을 그대로 비교하는 테스트는 불가능.

- “확장자가 제대로 붙는지”만 테스트하고 싶어도
랜덤 값 때문에 귀찮아짐.

### 2) 리팩토링 후 – extractExtension을 따로 테스트 가능

```java
// 예시: 단위 테스트 상상 코드
assertEquals(".png", extractExtension("dog.png"));
assertEquals(".gz", extractExtension("archive.tar.gz"));
assertEquals("",     extractExtension("noext"));
assertEquals("",     extractExtension(".hidden"));
assertEquals("",     extractExtension(null));
```

- 확장자 로직만 따로 떼서 검증할 수 있음.

- “로직이 제대로 동작하는지” 자신 있게 말할 수 있게 됨.

#### randomFileName()은:

- 길이, 패턴(예: .png로 끝나는지), null 아님 정도 만 체크하면 됨.

➡ 기능을 잘게 쪼개서 독립적으로 테스트할 수 있는 구조가
신뢰할 수 있는 코드의 기반이야.


## 6. 중복 제거(DRY) 효과

### 만약 확장자 처리 로직이 여러 곳에 퍼져 있으면 대충 이런 모양이 됨:

```java
// 이미지 저장 쪽
int idx = name.lastIndexOf(".");
String ext = "";
if (idx != -1) ext = name.substring(idx);
// ...

// 로그 기록 쪽
int idx = originalName.lastIndexOf(".");
String ext = "";
if (idx != -1) ext = originalName.substring(idx);
// ...

// 썸네일 생성 쪽
int idx = fileName.lastIndexOf(".");
String ext = "";
if (idx != -1) ext = fileName.substring(idx);
// ...
```

### 코드가 반복될수록:

- 버그 발생 가능성 ↑

- 수정 비용 ↑

- 읽기도 지저분


### 이걸 하나로 묶으면:
```java
String ext = extractExtension(fileName);
```

- DRY(Don’t Repeat Yourself) 원칙을 지키는 대표적인 리팩토링 패턴이야.


## 7. 요약 정리 

- 기존 randomName() 메서드 내부에 있던 파일 확장자 추출 로직을 extractExtension()이라는 별도 메서드로 분리했다.

- 이를 통해 단일 책임 원칙(SRP)을 지키고, 확장자 처리 정책 변경 시 한 곳만 수정하면 되도록 유지보수성을 높였다.

- 또한, 확장자 추출 기능을 다른 기능(로그 출력, 유효성 검사 등)에서도 재사용할 수 있게 되어 코드 중복(DRY)이 줄어들고, 단위 테스트도 용이해졌다.


---

# AI 활용보고서

- 사용 AI: ChatGPT 5
- 문제: 캠퍼스 플래너 콘솔 프로그램

---

### 학번: 20232002

### 이름 : 최소영

### 문제

GlossaryEntry.java - 전공 용어(이름, 정의, 카테고리, 난이도, 태그)를 안전하게 검증·정규화하여 저장하고 수정 이력을 관리하는 도메인 모델 클래스

---

### 프롬프트
생성자를 직접 호출하는 대신 정적 팩토리 메서드를 사용하면 기존 코드 대비 어떤 점들을 개선할 수 있을까?

---

### 결과 

## 정적 팩토리 메서드 사용의 개선점 

GlossaryEntry 리팩토링 과정에서 가장 중요한 변화 중 하나는

객체 생성 방식을 “직접 생성자 호출(new)”에서 “정적 팩토리 메서드(create)” 기반으로 재구성한 것이다.

이 변화는 단순한 코드 스타일 변경이 아니라,

객체 안정성(Validity), 설계 원칙 준수, 도메인 모델의 신뢰성 강화,

그리고 유지보수성·확장성의 근본적 향상을 가져온다.


## 1. 기존 코드 문제: 생성자가 모든 책임을 떠안고 있었다 (SRP 위반)

###  기존 나쁜 코드 — 생성자가 지나치게 많은 일을 함

```java
GlossaryEntry(long id, String term, String definition,
              String category, int difficulty, List<String> tags,
              LocalDate created, LocalDate updated) {

    this.id = id;
    this.term = (term == null) ? "" : term.trim();
    this.definition = (definition == null) ? "" : definition.trim();
    this.category = (category == null || category.isBlank()) ? "기타" : category.trim();
    this.difficulty = difficulty;
    this.tags = (tags == null) ? new ArrayList<>() : new ArrayList<>(tags);
    this.created = (created == null) ? LocalDate.now() : created;
    this.updated = (updated == null) ? this.created : updated;
}
```
#### 문제점

- 검증(validate)이 생성자 안에 섞여 있음

- 정규화(normalize)가 생성자 안에 섞여 있음

- 기본값 처리(defaulting)가 생성자 안에 섞여 있음

- 생성자가 하는 일이 너무 많음
- 
→ 단일 책임 원칙(SRP) 위반

#### 더 큰 문제

- 이 생성자는 public이기 때문에 어디서나 new GlossaryEntry(…)로 호출할 수 있다.

- 즉, 아래처럼 심각하게 잘못된 값을 넣어도 객체가 생성됨.
  
```java
new GlossaryEntry(1, null, "", "OS", 99, null, null, null);
```

## 2. 개선 코드: 생성자(private)는 순수한 필드 초기화만, 정적 팩토리 메서드가 검증을 책임진다

###  리팩토링 후 좋은 코드

- 생성자는 private으로 숨김 (외부에서 직접 호출 불가)
```java
private GlossaryEntry(
        long id,
        String term,
        String definition,
        String category,
        int difficulty,
        List<String> tags,
        LocalDate created,
        LocalDate updated
) {
    this.id = id;
    this.term = term;
    this.definition = definition;
    this.category = category;
    this.difficulty = difficulty;
    this.tags = (tags == null) ? new ArrayList<>() : new ArrayList<>(tags);
    this.created = created;
    this.updated = updated;
}
```

생성자는 순수하게 “필드 값 할당만” 하므로 아주 단순한 형태가 됨 → SRP 준수

### 정적 팩토리 메서드가 모든 검증을 담당
```java
public static GlossaryEntry create(
        long id, String term, String definition,
        String category, int difficulty, List<String> tags
) {
    validateTerm(term);
    validateDefinition(definition);
    validateDifficulty(difficulty);

    return new GlossaryEntry(
            id,
            term.trim(),
            definition.trim(),
            normalizeCategory(category),
            difficulty,
            normalizeTags(tags),
            LocalDate.now(),
            LocalDate.now()
    );
}
```

## 3. 검증(Validation)이 강제되어 객체의 “불변식(Invariant)”이 항상 보장된다

- 정적 팩토리 메서드는 다음과 같은 필수 검증을 수행한다.
- 
```java
private static void validateTerm(String term) {
    if (term == null || term.isBlank())
        throw new IllegalArgumentException("용어(term)는 비어 있을 수 없습니다.");
}

private static void validateDefinition(String definition) {
    if (definition == null || definition.isBlank())
        throw new IllegalArgumentException("정의(definition)는 비어 있을 수 없습니다.");
}

private static void validateDifficulty(int diff) {
    if (diff < 1 || diff > 5)
        throw new IllegalArgumentException("난이도는 1~5 사이여야 합니다.");
}
```

### 개선 효과

- GlossaryEntry는 “용어·정의·난이도”가 항상 유효한 상태로만 생성됨

- 오류가 만들어진 뒤에 발견되는 것이 아니라 애초에 생성 자체가 차단됨

➡ Fail-fast 설계 원칙 준수


## 4. 생성 시 정규화(Normalization)가 일관되고 재사용 가능해짐

기존 생성자 내부는 복잡한 정규화 로직이 섞여 있었지만

리팩토링 후에는 별도 메서드로 분리되어 재사용성·가독성 모두 향상됨.

```java
private static String normalizeCategory(String c) {
    return (c == null || c.isBlank()) ? null : c.trim();
}

private static List<String> normalizeTags(List<String> tags) {
    List<String> out = new ArrayList<>();
    if (tags != null) {
        for (String t : tags) {
            if (t != null && !t.isBlank()) {
                out.add(t.trim());
            }
        }
    }
    return out;
}
```

### 장점

- 규칙이 바뀌면 이 함수만 고치면 전체가 갱신됨

- 중복 제거 → 유지보수성 향상

- 데이터 일관성 강화

## 5. 객체의 “생성 규칙”을 한 곳에서만 관리하게 된다 (OCP 충족)

정적 팩토리 메서드가 있으면 생성 규칙을 바꿔도 create() 하나만 고치면 된다.

### 예를 들어 정책이 변경되어:

- 용어(term)를 자동으로 첫 글자만 대문자로 바꾼다거나

- 난이도를 입력하지 않으면 기본값 1을 준다거나

- category를 enum으로 바꾼다거나

→ 생성자 호출 코드들을 전부 수정할 필요가 없다.

#### → create() 내부만 수정하면 전체 프로젝트에 자동 적용됨

➡ 확장에는 열려 있고 수정에는 닫혀 있는(Open-Closed Principle) 구조가 된다.

## 6. 생성자보다 명확한 이름 덕분에 가독성 향상

###  기존: new GlossaryEntry(...)

- 어떤 값이 무엇을 의미하는지 읽기 어려움
  
```java
new GlossaryEntry(1, term, def, cat, diff, tags, LocalDate.now(), LocalDate.now());
```

###  리팩토링 후: GlossaryEntry.create(...)

- 코드 자체가 “GlossaryEntry 객체를 생성”한다는 의도를 드러냄
  
```java
GlossaryEntry.create(id, term, def, cat, diff, tags);
```

### 장점

- 읽기 쉬움

- 함수 이름만 봐도 어떤 객체가 만들어지는지 이해 가능

- 파라미터 의미를 파악하기 쉬움

## 7. 불변 필드 및 방어적 복사로 캡슐화 강화

### 리팩토링 후
```java
private final long id;
private List<String> tags;
```

그리고 tags 입력 시 항상 복사본을 생성한다.

```java
this.tags = (tags == null) ? new ArrayList<>() : new ArrayList<>(tags);
```

### 효과

외부에서 전달한 리스트를 그대로 참조하지 않음

외부에서 리스트를 수정해도 내부 데이터는 안전

객체 캡슐화 수준 대폭 증가

## 8. 정적 팩토리 메서드는 다양한 변형 기능을 제공할 수 있다

정적 팩토리 메서드는 생성자보다 훨씬 자유롭다.

예:

```java
public static GlossaryEntry empty() { ... }
public static GlossaryEntry fromCsv(String line) { ... }
public static GlossaryEntry defaultDifficulty(...) { ... }
```

생성자에서는 이런 유연한 확장이 불가능하다.


## 최종 요약 
###  정적 팩토리 메서드를 도입하며 개선된 핵심 사항

- 유효하지 않은 값으로 객체가 생성되는 문제 해결

- create() 내부에서 모든 검증과 정규화를 수행하여 객체의 무결성을 보장함.

- 객체 생성 규칙(Validation·Normalization)을 한 곳에서만 관리

- 규칙 변경 시 create()만 수정하면 전체 코드가 자동으로 반영되며 유지보수성이 크게 향상됨.

- 생성자(private) + 정적 팩토리 메서드 구조로 SRP·OCP 준수

- 생성자는 필드 초기화만 담당하고 , 생성 로직·검증 로직은 create()가 담당하여 역할이 분리됨.

- 방어적 복사와 불변 필드 적용으로 캡슐화 강화

- 외부에서 전달한 컬렉션이 내부 상태를 오염시킬 수 없도록 개선됨.

- new GlossaryEntry(…) 대신 GlossaryEntry.create(…)로 의미가 명확해짐.

- 추후 다형성 확장, 생성 정책 변경, 유틸 생성 메서드 추가가 쉬워짐 → 정적 팩토리 메서드는 생성자보다 훨씬 유연하다.

