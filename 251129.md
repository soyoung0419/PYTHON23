# AI 활용보고서

- 사용 AI: ChatGPT 5
- 문제: 캠퍼스 플래너 콘솔 프로그램

---

### 학번: 20232002

### 이름 : 최소영

### 문제

ImageHelper.java - 이미지 파일을 저장·열기·삭제하는 기능을 제공하는 유틸리티 클래스

---

### 프롬프트

기존 코드 randomName 내에 있는 파일 확장자 추출 로직을 별도 메서드로 분리하면 어떤 장점이 있는지 설명해줘

---

### 결과


좋은 질문이야!

아래는 기존 ImageHelper.randomName() 안에 있던 확장자 추출 로직을 별도 메서드로 분리했을 때의 장점을 정확히 짚어서 정리한 설명이야.


## 0. 전제 – 기존 코드 vs 리팩토링 코드

### 리팩토링 전(randomName 내부에 확장자 처리 포함)

```java
static String randomName(String originalName) {
    String ext = "";
    int idx = originalName.lastIndexOf(".");
    if (idx != -1) ext = originalName.substring(idx);
    return UUID.randomUUID().toString() + ext;
}
```

### 리팩토링 후(확장자 추출을 별도 메서드로 분리)

```java
// 1) 확장자만 추출하는 메서드
private static String extractExtension(String name) {
    if (name == null) return "";
    int idx = name.lastIndexOf(".");
    return (idx == -1) ? "" : name.substring(idx);
}

// 2) 랜덤 파일 이름 생성
private static String randomFileName(String original) {
    String ext = extractExtension(original);
    return UUID.randomUUID().toString() + ext;
}
```

즉, 기존에는 randomName()이 “확장자 추출 + UUID 생성”을 동시에 했는데,

리팩토링 후에는 “확장자 추출(extractExtension)”과 “랜덤 이름 생성(randomFileName)”이 역할을 나누어 맡게 된 것이 핵심이야.

## 1. 단일 책임 원칙(SRP) 관점에서의 장점

### 1) 리팩토링 전 – 하나의 메서드가 두 가지 역할 수행

```java
static String randomName(String originalName) {
    // (1) 확장자 추출 역할
    String ext = "";
    int idx = originalName.lastIndexOf(".");
    if (idx != -1) ext = originalName.substring(idx);

    // (2) 랜덤 파일명 생성 역할
    return UUID.randomUUID().toString() + ext;
}
```

이 메서드는:

- “파일 이름에서 확장자를 뽑아낸다.”

- “UUID로 랜덤 이름을 만든다.”

- 즉, 두 가지 책임을 동시에 가지고 있어.

- 나중에 “확장자 처리 방식”만 바꾸고 싶어도 randomName()을 뜯어고쳐야 해.


### 2) 리팩토링 후 – 책임이 명확하게 분리

```java
private static String extractExtension(String name) {
    if (name == null) return "";
    int idx = name.lastIndexOf(".");
    return (idx == -1) ? "" : name.substring(idx);
}

private static String randomFileName(String original) {
    String ext = extractExtension(original);
    return UUID.randomUUID().toString() + ext;
}
```

- extractExtension : **“파일 이름 → 확장자 문자열”**만 담당

- randomFileName : **“랜덤 파일 이름 생성”**만 담당
(확장자 처리 세부 로직은 신경 쓰지 않음)

-> SRP(단일 책임 원칙) 관점에서 볼 때,

각 메서드가 “딱 한 가지 일만 하는 구조”가 돼서

이해하기도 쉽고, 변경 범위도 줄어들어.

## 2. 재사용성(Reuse) 증가

확장자 추출 로직은 랜덤 이름 만들 때만 필요한 게 아니야. 

### 예를 들어:

- 이미지 파일 업로드 시,

- “허용 확장자인지 검사해야 할 때” (.jpg/.png만 허용 등)

- 로그를 찍을 때 “파일명과 확장자를 분리해서 보여주고 싶을 때”

### 향후:

- 썸네일 생성 기능

- 파일 미리보기 기능

- 백업/복원 기능 등

이때 확장자 추출 코드가 randomName() 안에 박혀 있으면

재사용하려면 똑같은 로직을 또 작성해야 해.

### 하지만 이렇게 되어 있으면:

```java
String ext = extractExtension(fileName);
```

어디서든 한 줄로 가져다 쓸 수 있음.

즉,

“확장자 추출”은 도메인에서 꽤 자주 쓰이는 공통 로직이기 때문에 별도의 메서드로 빼는 게 재사용 측면에서 훨씬 합리적이야.


## 3. 유지보수성(Maintainability) 향상

### 상황 가정

나중에 요구사항이 바뀐다고 해보자:

1. .jpeg → .jpg로 통일해서 저장해야 한다.

2. 확장자가 없으면 .png를 기본으로 붙여야 한다.

3. .tar.gz처럼 복잡한 확장자를 처리해야 한다.

4. 대문자 확장자(.PNG)도 모두 소문자로 변환해야 한다.

이런 요구사항이 생겼을 때, 리팩토링 후 구조에서는:

```java
private static String extractExtension(String name) {
    if (name == null) return "";

    int idx = name.lastIndexOf(".");
    if (idx == -1) {
        // 확장자 없는 경우 기본값
        return ".png";
    }

    String ext = name.substring(idx).toLowerCase(Locale.ROOT);

    if (ext.equals(".jpeg")) {
        return ".jpg";
    }

    return ext;
}
```

- 이 메서드 하나만 수정하면 전체 동작이 바뀜.

- 랜덤 파일명 만드는 로직, 이미지 저장 로직 등은 손댈 필요 없음.

반대로, 확장자 추출이 randomName()에 박혀 있고,

다른 곳에서도 비슷한 코드를 복붙해서 쓰고 있었다면?

- 여러 곳을 동시에 수정해야 하고

- 하나라도 빼먹으면 버그가 됨

- “어디 어디에 비슷한 로직이 있는지” 찾는 것도 고역

➡ 확장자 처리 정책이 바뀌었을 때 변경 지점이 한 곳으로 모이도록 만드는 게
리팩토링의 핵심 장점 중 하나야.

## 4. 가독성(Readability) 향상

### 리팩토링 전 코드를 처음 보는 사람 입장에서 보면:

```java
String ext = "";
int idx = originalName.lastIndexOf(".");
if (idx != -1) ext = originalName.substring(idx);
return UUID.randomUUID().toString() + ext;
```

- “아, 여기서 점의 위치를 찾네? 그다음 substring? 아, 확장자 뽑는 거구나…”

- 의미를 이해하려면 구현 세부 내용을 따라가야 함


### 리팩토링 후에는:

```java
String ext = extractExtension(original);
return UUID.randomUUID().toString() + ext;
```

- extractExtension()이라는 이름에서 이미 의도가 드러남.

- 구현을 보지 않고도 / 한 번만 봐도 무슨 역할인지 바로 이해 가능.

- 즉, “코드를 읽는 사람의 뇌 사용량을 줄여주는 것”도 중요한 개선점이야.


## 5. 테스트 용이성(Testability) 증가

테스트 관점에서 이 차이는 더 크게 느껴져.

### 1) 리팩토링 전 – randomName만 있음

```java
randomName("dog.png") → "무작위UUID.png"
```

#### 문제:

- UUID가 매번 바뀌기 때문에 결과 문자열을 그대로 비교하는 테스트는 불가능.

- “확장자가 제대로 붙는지”만 테스트하고 싶어도
랜덤 값 때문에 귀찮아짐.

### 2) 리팩토링 후 – extractExtension을 따로 테스트 가능

```java
// 예시: 단위 테스트 상상 코드
assertEquals(".png", extractExtension("dog.png"));
assertEquals(".gz", extractExtension("archive.tar.gz"));
assertEquals("",     extractExtension("noext"));
assertEquals("",     extractExtension(".hidden"));
assertEquals("",     extractExtension(null));
```

- 확장자 로직만 따로 떼서 검증할 수 있음.

- “로직이 제대로 동작하는지” 자신 있게 말할 수 있게 됨.

#### randomFileName()은:

- 길이, 패턴(예: .png로 끝나는지), null 아님 정도 만 체크하면 됨.

➡ 기능을 잘게 쪼개서 독립적으로 테스트할 수 있는 구조가
신뢰할 수 있는 코드의 기반이야.


## 6. 중복 제거(DRY) 효과

### 만약 확장자 처리 로직이 여러 곳에 퍼져 있으면 대충 이런 모양이 됨:

```java
// 이미지 저장 쪽
int idx = name.lastIndexOf(".");
String ext = "";
if (idx != -1) ext = name.substring(idx);
// ...

// 로그 기록 쪽
int idx = originalName.lastIndexOf(".");
String ext = "";
if (idx != -1) ext = originalName.substring(idx);
// ...

// 썸네일 생성 쪽
int idx = fileName.lastIndexOf(".");
String ext = "";
if (idx != -1) ext = fileName.substring(idx);
// ...
```

### 코드가 반복될수록:

- 버그 발생 가능성 ↑

- 수정 비용 ↑

- 읽기도 지저분


### 이걸 하나로 묶으면:
```java
String ext = extractExtension(fileName);
```

- DRY(Don’t Repeat Yourself) 원칙을 지키는 대표적인 리팩토링 패턴이야.


## 7. 요약 정리 

- 기존 randomName() 메서드 내부에 있던 파일 확장자 추출 로직을 extractExtension()이라는 별도 메서드로 분리했다.

- 이를 통해 단일 책임 원칙(SRP)을 지키고, 확장자 처리 정책 변경 시 한 곳만 수정하면 되도록 유지보수성을 높였다.

- 또한, 확장자 추출 기능을 다른 기능(로그 출력, 유효성 검사 등)에서도 재사용할 수 있게 되어 코드 중복(DRY)이 줄어들고, 단위 테스트도 용이해졌다.
