---

### 프롬프트

Friend 엔티티에서 id 필드를 불변(final)으로 설정하고, name·uid·tag만 setter로 변경 가능하도록 설계했는데, 이러한 구조가 데이터 무결성과 객체 신뢰성을 높이는 데 어떤 역할을 하는지, 기존 나쁜 코드와 비교하여 설명해줘

---

### 결과

아주 좋은 질문이야.


## Friend 엔티티에서 id를 불변(final)으로 만들고, name·uid·tag만 setter로 변경 가능하도록 설계한 이유

### 1) id를 final로 두면 데이터 무결성이 보장된다

id는 Friend 엔티티의 고유 식별자(Primary Key) 역할을 한다.

즉, 이 값은 객체를 구분하는 단 하나의 값이다.

#### id가 변경될 수 있으면 어떤 문제가 생기나?

- 객체를 저장한 후 id가 바뀌면

→ 저장소(List, DB, LocalStore)에서 찐 객체를 찾을 수 없음

- 업데이트/삭제 시

→ 어떤 객체를 대상으로 작업해야 하는지 추적 불가능

- 다른 계층(ViewModel, Service)에서 참조하던 id가

→ 더 이상 일치하지 않아 데이터 엉킴

즉, PK가 변경 가능하면 전체 시스템의 참조 무결성이 무너진다.

#### final id는 이러한 문제를 완전히 차단하는 장치임

- id가 생성 시점에만 세팅되고 절대 변하지 않으므로:

엔티티는 생성 이후 항상 동일한 식별자를 가진다.

- 어떤 저장 구조(List, Map, DB)에서도 안정적으로 참조 가능하다.

- 전체 시스템에서 “이 Friend는 이 ID이다”라는 사실이 불변하게 유지된다.

###  2) name, uid, tag만 setter로 허용한 이유

반대로, name, uid, tag는 사용자가 수정할 수 있는 속성이다.

- 이름 변경

- UID 재발급

- 태그 변경

같은 변화는 도메인상 자연스럽고 허용해야 한다.

따라서 setter 제공 = 도메인 규칙상 변화가 허용되는 필드만 변경 가능하도록 제어한다.

### 3) 이렇게 “부분 불변 객체”로 만드는 구조가 객체 신뢰성을 높이는 이유
#### (1) 객체를 사용하는 모든 계층이 안심하고 ID를 신뢰할 수 있다

ViewModel, Service, Repository 등 모든 계층이
“이 id는 절대 바뀌지 않는다”는 사실을 전제로 동작한다.

이로 인해:

- 흐름 추적이 단순해지고

- 동시성 문제(멀티스레드)도 줄어들고

- 디버깅할 때 상태 변화를 걱정할 필요 없음

즉: ID 불변 = 시스템 안정성 핵심 축

#### (2) 저장소 무결성 보장

저장소(List<Friend>, DB, LocalStore)에서

동일한 객체를 정확히 찾고 업데이트하거나 삭제하려면

id가 절대 바뀌면 안 된다.

만약 id가 변경 가능하면?

- update 하지 못함 (id로 찾으니까)

- delete도 실패함

- 저장된 객체와 메모리의 객체가 불일치함

→ “유령 데이터(ghost data)” 발생 가능

final id는 이런 문제를 원천적으로 제거한다.

#### (3) equals/hashCode 일관성 보장

비록 지금 equals/hashCode는 오버라이드하지 않았지만,

식별자 기반 equals/hashCode를 도입할 때

id가 변하면 절대 안 된다.

id가 불변이면:

- HashMap, HashSet, TreeSet 등에서 안전하게 사용 가능

- 컬렉션 내부 구조가 깨지는 사고를 방지

즉, 객체의 정체성이 유지된다.

### 4) 기존 나쁜 코드에서는 어떤 문제가 있었나?

기존 CampusPlannerConsole 구조에서는:

#### 문제 1) id가 생성 후에도 변경될 수 있는 구조였다

- Friend 객체가 하나의 거대한 데이터 구조 내부에서 이동될 가능성이 있고

- setter가 존재하거나 값이 여러 곳에서 변형될 수 있었음

- 저장소에서 어떤 Friend가 어떤 id인지 불명확해지는 구조

→ 데이터 무결성 붕괴

#### 문제 2) 엔티티에 책임이 너무 많았다

- 저장소에 접근하거나

- 검증을 수행하거나

- UI 흐름에서 조작되거나

즉, 엔티티 자체의 상태가 예측 불가능한 형태로 변할 수 있었다.

→ 객체 신뢰성 저하

#### 문제 3) id를 마음대로 수정할 수 있었기 때문에 참조가 끊어졌다

예를 들어,
```
Friend f = repo.findById(3L); 
f.setId(10L);  // 이런 구조가 가능함
```


그럼:

- Repository는 여전히 id=3을 가진 객체를 찾음

- UI는 id=10이라고 판단

- 실제 저장소는 id=3으로 저장되어 있음

완전한 데이터 불일치 → 데이터 무결성 큰 문제

#### 문제 4) 객체가 가진 값의 “역할”이 불명확했다

기존 코드에서는:

- 어떤 필드는 수정 가능해도 되고

- 어떤 필드는 수정되면 안 되는데

이 기준이 전혀 분리되어 있지 않았다.

#### 5) 좋은 코드에서는 어떤 점이 개선되었나?
- 개선 1) id는 절대 변하지 않는 고유 식별자로 확정

→ 데이터 정합성, 참조 무결성, 안정성 상승

- 개선 2) 변경 가능한 필드(name/uid/tag)만 setter 제공

→ 변경 가능한 속성과 변경 불가능한 속성이 명확히 분리됨

- 개선 3) 엔티티의 책임이 최소화됨 (Pure Data Model)

→ 모든 규칙은 Service
→ 모든 저장은 Repository
→ 모든 UI는 ViewModel
→ 엔티티는 오직 “데이터 담는 역할”

- 개선 4) 코드 흐름이 명확해지고 예측 가능한 구조로 바뀜

→ 리팩터링 후 유지보수성 대폭 상승

 
 ## 결론 정리

Friend 엔티티에서 id를 final로 만들고
나머지 필드(name, uid, tag)를 setter로만 수정 가능하게 만든 설계는:

- 데이터 무결성 확보

- 객체 신뢰성(Identity consistency) 보장

- 저장소(LocalStore/List/DB)와의 참조 안정성 유지

- 수정 가능한 값과 불변 값을 명확하게 분리해 역할을 명확히 함

- 기존 나쁜 코드에서 발생했던 데이터 불일치/혼동 문제를 완전 해결함

이렇게 정리할 수 있다.
