# AI 활용 보고서

- 사용 AI: ChatGPT 5
- 문제: 캠퍼스 플래너 콘솔 프로그램

---

### 학번 : 20232002
### 이름: 최소영

### 문제 
GlossaryHandler.java - 

---

### 프롬프트
메소드 분리 방식, Command 패턴, MVC 패턴 중 어떤 게 가장 적합한지 비교해줘.

---

### 결과

아래는 기존 handleGlossary() 코드 리팩토링 방안으로 자주 거론되는

1. 단순 메소드 분리 방식

2. Command 패턴 적용

3. MVC(MVVM 포함) 구조 적용

이 세 가지를 비교 분석하여

 “어떤 방식이 가장 적합한가?”에 대한 결론을 제시한 내용이다.

## 1. 단순 메소드 분리 방식

개념

기존 하나의 거대한 handleGlossary()에서

- add()

- edit()

- delete()

- search()

- listAll()

- quiz() ...

과 같은 기능을 메소드로만 쪼개는 방식이다.

즉, “Switch-case 내부 로직을 별도 함수로 분리”만 수행하는 최소 리팩토링

### 장점 

####  1) 구현이 가장 쉽다

- 구조 변경 부담이 적음

- 새 파일 생성 없이 기존 클래스 내부만 정리 가능

#### 2) 가독성 향상

switch 구조는 유지하지만

각 기능 단위로 코드가 분리되므로

300줄짜리 코드가 20~30줄로 나뉨

#### 3) 유지보수성이 조금 나아짐

- 특정 기능을 찾기 쉬움

### 단점 

#### SRP 해결은 제한적

UI 처리, 입력 검증, 데이터 조작 로직이 여전히 섞여 있음

#### 테스트 불가능 문제 해결 X

- 여전히 System.in/System.out에 의존

- ViewModel 로직과 UI 흐름이 분리되지 않음

#### 확장성 부족

예: 메뉴가 20개로 늘어나면

switch문은 그대로 비대해짐

#### SOLID 위반 일부 남음

특히 OCP

기능 추가 시 switch-case에 새로운 분기문이 반드시 추가된다

→ 코드 수정 필요 → OCP 위반 유지

#### 종합 평가

- 가장 가벼운 리팩토링이지만 “근본적 문제 해결”은 못함

- 구조가 깔끔해진 느낌은 들지만

아키텍처 품질 자체는 크게 달라지지 않는다.

- 테스트 가능성, 역할 분리, UI/로직 혼재 문제는 여전히 남는다.

## 2. Command 패턴 적용 방식

개념

각 명령(a, e, d, s, ...)을

별도의 Command 클래스로 분리하는 방식

예:

```java
interface GlossaryCommand {
    void execute();
}
```

그리고 각 기능을 구현:

```java
class AddCommand implements GlossaryCommand {
    public void execute() {
        // add logic
    }
}
```

Command 매핑:
```java
Map<String, GlossaryCommand> commands;
```

UI 입력:
```java
GlossaryCommand cmd = commands.get(userInput);
cmd.execute();
```

### 장점 
 
#### switch-case 제거
```java
switch(cmd) {
    case "a": ...
}
```

➡ 없어짐

#### OCP 해결

새 기능(예: 정렬 기능)을 추가할 때

기존 코드를 건드리지 않고

Command만 추가하면 됨
```java
commands.put("sort", new SortCommand(...));
```

기존 Handler 수정 X → OCP 충족

#### 테스트 쉬워짐 (부분적 해결)

Command 객체 단독 테스트 가능
```java
new AddCommand(vm, mockInput, mockOutput).execute();
```

UI 없이 Add 기능만 테스트 가능

#### 역할 분리 시도 가능

- UI

- 입력 처리

- 비즈니스 로직(Command 내부)

구분 가능

### 단점 

#### Command 객체가 너무 많아질 수 있음

메뉴가 늘어나면 클래스 파일 개수가 폭증

10개의 메뉴 → 10개의 Command 클래스

규모가 작은 앱이면 오히려 “과 설계(Over Engineering)”이 된다.

#### UI 처리 로직이 여전히 Command에 남을 가능성

Command 내부에서 System.out/System.in으로 입출력 처리하면

UI와 도메인이 진짜로 분리된 건 아님

즉, 구조는 세련되어 보이는데 핵심 문제는 해결 안 될 수도 있음

#### ViewModel과 Handler, Command 사이 결합도 조절 필요

DI 구조를 설계하지 않으면 또다른 의존성 문제가 발생할 수 있다.

### 종합 평가

중규모 이상 확장될 가능성이 있을 때 굉장히 좋은 선택

단,

Console 기반 입력

UI/입력 검증/출력까지 모두 Command 클래스 안에 남는다면

단순 switch 분리 수준에서 벗어나지 못하는 “형식적 리팩토링”이 된다.

## 3. MVC(or MVVM) 구조 적용

개념

UI, Handler, ViewModel, Entity 계층을 명확하게 분리하는 구조

아래 같은 계층 배치:

```java
View(UI) — GlossaryHandler(Control) — GlossaryViewModel — Model(GlossaryEntry)
```


| 계층 | 책임 |
|------|------|
| UI(View) | 사용자 입력/출력 담당 (콘솔, 화면 표시 등) |
| Handler(Controller) | 사용자 명령 해석, 입력값 수집, ViewModel 호출, 흐름 제어 |
| ViewModel(Model Logic) | 검증 로직 수행, 도메인 규칙 처리, CRUD 비즈니스 로직, 검색/필터링 관리 |
| Model(Entity) | 데이터 구조 저장 (GlossaryEntry 등), ID/Term/Category/Definition/Tags 보유 |

### 장점 

####  명확한 책임 분리 (SRP 완벽 해결)

handleGlossary()에 섞여 있던 역할이 유기적으로 분리된다.

#### 테스트가 매우 쉬워진다

테스트 코드는 ViewModel만 검증하면 됨

```java
GlossaryEntry e = vm.add("TCP", "전송", "CN", 3, "network");
assertEquals("TCP", e.getTerm());
```

UI 입력 없이 비즈니스 로직 테스트 가능

#### UI 교체 가능

Console → GUI → Web으로 변경해도 ViewModel과 Domain은 유지

(핵심 로직이 UI에 묶여있지 않음)

#### 확장성 최고

- DB 교체

- CSV, JSON Export 추가

- 메뉴 기능 확장

- Handler만 조정하면 됨

- 도메인 핵심 규칙은 ViewModel에 통합되어 있음

#### OCP/SRP/DIP 모두 충족 가능

UI 변경 시 도메인 코드 수정 불필요

### 단점 

#### 설계 비용이 가장 큼

계층 도입

Handler 분리

ViewModel 정립

Domain과 UI 구분

이 과정이 필요하며

초기 작업량이 단순 메소드 분리 대비 훨씬 크다.

#### 프로젝트가 지나치게 작은 경우엔 과설계 가능

하지만 Glossary 기능처럼 CRUD + 검색 + 퀴즈 + export 기능이 많다면

적절한 설계라고 볼 수 있다.

## 최종 결론

핵심 로직도 단순하지 않고

CRUD

검색

카테고리 조회

랜덤 퀴즈

CSV export

난이도 관리

태그 관리

같은 기능을 포함하고 있다는 점에서

단순한 “메소드 분리 수준”으로 해결할 수 있는 구조적 문제가 아니다.

또한 Glossary 기능은

“나중에 GUI로 확장하거나 Web 기반 모듈로 바꿀 가능성”도 충분히 있기 때문에 UX/UI와 핵심 로직을 분리한 구조가 맞다.

## 결론 추천 순위

| 방식 | 적합성 판단 |
|------|------------|
| 메소드 분리 | ★☆☆☆☆ (개선 효과 매우 제한적) |
| Command 패턴 | ★★★☆☆ (OCP 측면에서 장점은 있으나 구조적 완성도는 부족) |
| MVC / MVVM 구조 | ★★★★★ (가장 깔끔하며 테스트 용이성과 확장성을 모두 확보 가능) |

## 결론 핵심 문장

Glossary 기능의 규모와 확장 가능성을 고려할 때, 단순 메소드 분리 방식은 구조적 문제를 근본적으로 해결하지 못한다. 

Command 패턴은 switch 분기에 대한 OCP 문제를 해결해줄 수 있지만, UI 처리와 도메인 로직이 뒤섞여 있다는 핵심 결함은 여전히 남는다. 

반면 MVC/MVVM 구조는 UI(View), 흐름 처리(Handler/Controller), 핵심 로직(ViewModel)을 명확히 분리하여 테스트 가능성과 확장성을 보장한다. 

따라서 이 코드에서는 MVC(MVVM 포함) 패턴 적용이 가장 적합한 리팩토링 방식이다.

원하면 

- MVC 적용된 코드 구조 예시

- 패키지 구조 설계

- Handler/ViewModel Interface 설계
  
까지 상세 버전으로 만들어줄게!
