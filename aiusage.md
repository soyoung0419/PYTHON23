# AI 활용보고서


## *질문 1

- 사용 AI: ChatGPT 5
- 문제: 캠퍼스 플래너 콘솔 프로그램

---
**프롬프트**
<br>친구 UID가 중복되는지 먼저 검사해야 하는데, 이런 검사는 DAO와 ViewModel 중에 어디서 수행해야 할까?

---

**결과**
<br>좋은 질문이야!  답을 설계 관점에서 정리해서 설명해줄게.

<br>✅ 친구 UID 중복 검사 — DAO vs ViewModel 어디서 하는 게 맞을까?
| 기준     | DAO에서 검사                                                                          | ViewModel에서 검사                                                                      |
|----------|---------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|
| **역할** | 데이터 저장/조회/삭제 등 “저장소와 직접 상호작용”                                      | 사용자 입력과 비즈니스 로직 처리                                                        |
| **장점** | - 데이터 중복이 저장소에 들어가는 것을 가장 근본적으로 막을 수 있음<br>- 다른 계층(ViewModel, UI)이 실수해도 안전하게 보장됨 | - UI 혹은 사용자 흐름에 따라 안내 메시지를 제공하거나 예외 처리하기 쉬움<br>- 사용자 친화적인 메시지 가능 |
| **단점** | - 비즈니스 로직까지 DAO에 넣으면 역할이 무거워짐<br>- MVC/MVVM 규칙에서 벗어나기 쉬움 | - ViewModel에서만 중복 검사를 하고 DAO를 그대로 저장하면, 다른 코드에서 DAO를 직접 호출할 경우 중복 데이터 저장 위험 존재 |
| **결론** | “저장되는 데이터 무결성”을 보장하려면 **DAO에서도 최종적으로 검증하는 것이 바람직**         | “사용자 안내 및 흐름 제어”는 **ViewModel에서 먼저 검사 후 DAO에 전달하는 구조가 이상적**      |



<br>✅ 가장 이상적인 구조는?
<br>✔ 1차 검사 → ViewModel에서
```plaintext
if (friendDao.existsByUid(uid)) {
    throw new IllegalArgumentException("이미 존재하는 UID입니다.");
}
friendDao.addNew(name, uid);
```

<br>✔ 2차 (최종) 보증 → DAO 내부에서도 확인 가능 (선택적)
```plaintext
Friend addNew(String name, String uid) {
    if (friends.stream().anyMatch(f -> f.uid.equals(uid))) {
        throw new IllegalStateException("중복 UID 저장 시도!");
    }
    // 안전하게 저장
}
```

<br>✅ 요약하면,

“입력 흐름과 사용자 메시지를 담당하는 ViewModel에서 먼저 검사하고,
데이터의 최종 무결성을 보장하는 DAO에서 한 번 더 안전장치로 확인하는 것이 가장 좋은 구조다.”

--- 
<br><br><br>




## *질문 2
- 사용 AI: ChatGPT 5
- 문제: 캠퍼스 플래너 콘솔 프로그램

---

**프롬프트**

<br>DAO가 애플리케이션 구조에서 어떤 역할을 수행하지는지 , UID 중복 검사 같은 검증도 포함할 수 있는지 알고싶어

---

**결과**


<br>DAO에 대해 궁금해한 내용을 기반으로, 이해하기 쉽게 정리해줄게!


<br>✅ DAO(Data Access Object)는 애플리케이션 구조에서 정확히 어떤 역할을 수행할까?

DAO는 애플리케이션에서 데이터를 저장하고 불러오는 모든 작업을 전담하는 계층이다.
예를 들어 CampusPlanner에서는 FriendDao, DiaryDao, TaskDao 등이 이 계층에 해당한다. 이 객체들은 단순히 자료구조(List)에 데이터를 넣는 것이 아니라, LocalStore와 program_data.bin 파일에 데이터를 안정적으로 저장하고, 필요한 데이터를 찾아 전달하는 역할을 맡는다.

- UI 또는 ViewModel이 직접 파일을 다루면 생기는 문제
UI 코드에서 파일을 저장/읽기까지 처리한다면, 코드가 매우 복잡해지고 유지보수가 어려워진다. 또한 파일 저장 방식이 바뀌거나, DB를 도입하려 할 때 프로그램 전체를 수정해야 한다.

- DAO가 존재하면 해결되는 부분
DAO가 데이터 저장/수정/삭제/조회를 모두 담당하기 때문에, ViewModel이나 UI는 오직 “무엇을 해야 하는지”만 결정하고, “어떻게 저장할지”는 DAO에 맡기면 된다.
즉, DAO는 비즈니스 로직과 데이터 저장 방식을 분리해 코드의 재사용성과 유지보수성을 높여주는 핵심 구조이다.


<br>✅ UID 중복 검사 같은 데이터 검증도 DAO가 담당할 수 있을까?

이 질문은 매우 중요한데, 결론부터 말하면:

DAO는 “데이터를 저장할 때 절대 깨지지 않도록 보장해야 하는 검증”을 포함할 수 있다.
단, “사용자에게 보여줄 안내 메시지나 UI 흐름 제어”는 DAO가 아니라 ViewModel이나 Controller가 가져가야 한다.


<br>✔ DAO가 검증을 포함해도 좋은 상황
| 상황                                   | 이유                                                                 |
| -------------------------------------- | -------------------------------------------------------------------- |
| UID가 중복된 친구가 저장되는 경우를 막아야 할 때         | 이는 **데이터 무결성(Data Integrity)** 문제이므로, DAO가 저장 직전에 검증해야 안전함 |
| 여러 ViewModel이나 기능에서 동일한 DAO를 사용할 때 | ViewModel에서 검증을 놓쳐도 DAO가 최종 방어선 역할을 하며 잘못된 데이터 저장을 막아야 함 |
| 저장소(DB, 파일)가 손상되거나 이상한 값이 들어가는 것을 방지하고 싶을 때 | DAO가 데이터 저장 전 마지막 필터 역할을 하며 저장소를 보호해야 함                        |


<br>✘ DAO에 넣으면 좋지 않은 검증/기능
| 포함하면 안 되는 것                                  | 이유                                                                 |
| ---------------------------------------------------- | -------------------------------------------------------------------- |
| `"UID가 중복되었습니다. 다시 입력하세요."` 같은 출력 처리 | 이는 **UI/사용자 경험(UI/UX)** 영역이며, DAO가 담당하면 역할이 혼란스러워짐   |
| 메뉴 이동, 화면 갱신 같은 UI 흐름 제어                       | DAO는 **데이터 저장/조회만 책임**지고, 화면 흐름은 ViewModel 또는 UI 계층이 담당해야 함 |


<br>✅ 정리하면 이렇게 말할 수 있다

- DAO는 데이터 저장소(LocalStore + 파일)를 안전하게 다루는 전담 계층이다.

- DAO는 단순 CRUD를 넘어서, 데이터 무결성을 보장하기 위한 기본적인 검증 (예: UID 중복 여부) 을 수행할 수 있다.

- 그러나 사용자 안내 메시지, 에러 출력, 입력 요청 같은 UI/흐름 제어는 DAO에서 하면 안 되고 ViewModel/UI가 담당해야 한다.

- 이렇게 역할을 분리하면, 코드 테스트가 쉽고 유지보수성이 좋아지며, 나중에 DB나 클라우드 시스템으로 바꾸더라도 DAO만 수정하면 전체 코드가 그대로 동작한다.


<br>✅설계 예시로 보면 더 이해 쉬움




---
<br><br><br>




## *질문 3

- 사용 AI: ChatGPT 5
- 문제: 캠퍼스 플래너 콘솔 프로그램

---

**프롬프트**

<br>다이어리 화면에서 해당 날짜의 Task(할 일)를 같이 보여주는 기능(tasksDueOn)처럼, 기능을 서로 연결시켜도 될까, 아니면 분리해야 할까?

---

**결과**

<br>현재 코드에서는 CalendarViewModel이 DiaryDao와 TaskDao를 동시에 참조하며, 아래 기능을 제공하고 있습니다:

```plaintext
List<Diary> diariesOn(LocalDate date);
List<Task> tasksDueOn(LocalDate date);
```

즉, 사용자가 특정 날짜를 조회하면, 그 날 작성된 다이어리 + 마감일이 오늘인 할 일 목록을 함께 제공하는 구조입니다. 이 방식의 적절성을 기술적으로, 설계적으로 분석하면 다음과 같습니다.


<br>📌 1. 기능을 연결하는 접근 (현재 코드 구조의 장점)

<br>1. 사용자 경험(UX)이 좋아짐

- 한 날짜에 대해 “무엇을 했는지(일기)”와 “무엇을 해야 하는지(Task)”를 동시에 보여주는 것은 실제 일정 관리 앱(예: Google Calendar, Notion, Daylio)에서도 흔히 사용하는 방식입니다.

- 사용자가 날짜를 기준으로 정보를 모아보는 입장에서 훨씬 직관적입니다.

<br>2. CalendarViewModel이 중간 조정자 역할을 수행

- Diary와 Task는 독립적인 DAO/Model로 존재하지만, CalendarViewModel이 단일 API를 통해 묶어 줌으로써 UI 코드(handleDiary())에서는 두 클래스를 직접 다루지 않아도 됩니다.

- 즉, UI → ViewModel → DAO 흐름이 깔끔하게 유지됨.

<br>3. 비즈니스 로직의 위치가 명확함

- Diary 자체는 “글을 저장하는 기능”만 담당.

- Task는 “마감일 관리 + 알림 기능” 담당.

- “날짜 기준으로 Diary + Task를 동시에 보여주는 건 Calendar(달력) 문맥에서만 필요한 비즈니스 로직이므로”, CalendarViewModel이 담당하는 것이 설계적으로 적절합니다.

  

<br>📌 2. 그렇다면 기능 분리가 더 적절한 경우는 언제일까?
<br>하지만 항상 이런 결합 구조가 좋은 것은 아닙니다. 아래의 경우에는 분리도 고려해야 합니다.

| 분리해야 할 상황                             | 이유                                                                 |
| ------------------------------------------- | -------------------------------------------------------------------- |
| **Diary와 Task가 완전히 독립적인 기능으로 운영될 때**  | 다이어리만 따로 저장하거나 공유 기능이 추가되면, Task와 관계없이 동작해야 하기 때문 |
| **CalendarViewModel이 기능 확장으로 비대해질 때** | Diary + Task + 시험 일정 + 출석 정보 등 기능이 늘어나면, 클래스를 분리하는 것이 유지보수에 유리 |
| **API 서버나 모바일 앱으로 확장될 가능성이 있을 때** | REST API나 Firebase에서는 `/tasks`와 `/diaries`를 각각 독립된 컨트롤러나 서비스로 관리하는 것이 일반적 |


---
